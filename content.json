{"meta":{"title":"dubo blog","subtitle":"爱生活、爱骑行、爱旅行","description":null,"author":"dubo","url":"http://flame160.git.io"},"pages":[],"posts":[{"title":"七牛云图片外链失效","slug":"七牛云图片外链失效","date":"2018-12-18T13:48:56.000Z","updated":"2018-12-18T13:51:55.031Z","comments":true,"path":"2018/12/18/七牛云图片外链失效/","link":"","permalink":"http://flame160.git.io/2018/12/18/七牛云图片外链失效/","excerpt":"本博客之前的图片一直是用七牛云存储的，今天发现博客图片外链全都失效了，七牛云存储图片全部都无法显示，七牛云收回了所有的测试域名，并且七牛云后台也无法显示和下载图片。为了解决这个问题，可以使用qrsctl工具下载图片，","text":"本博客之前的图片一直是用七牛云存储的，今天发现博客图片外链全都失效了，七牛云存储图片全部都无法显示，七牛云收回了所有的测试域名，并且七牛云后台也无法显示和下载图片。为了解决这个问题，可以使用qrsctl工具下载图片，","categories":[{"name":"日志","slug":"日志","permalink":"http://flame160.git.io/categories/日志/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://flame160.git.io/tags/hexo/"},{"name":"七牛云","slug":"七牛云","permalink":"http://flame160.git.io/tags/七牛云/"}]},{"title":"七牛云图片失效及Hexo上传图片","slug":"七牛云图片下载及Hexo上传图片","date":"2018-12-18T13:17:50.000Z","updated":"2018-12-18T13:50:45.438Z","comments":true,"path":"2018/12/18/七牛云图片下载及Hexo上传图片/","link":"","permalink":"http://flame160.git.io/2018/12/18/七牛云图片下载及Hexo上传图片/","excerpt":"本博客之前的图片一直是用七牛云存储的，今天发现博客图片外链全都失效了，七牛云存储图片全部都无法显示，七牛云收回了所有的测试域名，并且七牛云后台也无法显示和下载图片。为了解决这个问题，可以使用qrsctl工具下载图片，","text":"本博客之前的图片一直是用七牛云存储的，今天发现博客图片外链全都失效了，七牛云存储图片全部都无法显示，七牛云收回了所有的测试域名，并且七牛云后台也无法显示和下载图片。为了解决这个问题，可以使用qrsctl工具下载图片，","categories":[{"name":"日志","slug":"日志","permalink":"http://flame160.git.io/categories/日志/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://flame160.git.io/tags/hexo/"},{"name":"七牛云","slug":"七牛云","permalink":"http://flame160.git.io/tags/七牛云/"}]},{"title":"C++基本知识","slug":"C-基本知识","date":"2017-05-23T06:46:04.000Z","updated":"2018-03-29T11:55:21.209Z","comments":true,"path":"2017/05/23/C-基本知识/","link":"","permalink":"http://flame160.git.io/2017/05/23/C-基本知识/","excerpt":"C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++是一门面向对象的语言，其中有许多概念容易混淆，并且在笔试和面试的过程中也有较多的涉及。下面整理了一些C++的基本知识，以供参考。","text":"C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++是一门面向对象的语言，其中有许多概念容易混淆，并且在笔试和面试的过程中也有较多的涉及。下面整理了一些C++的基本知识，以供参考。 1. sizeof()和strlen() sizeof()是运算符，在头文件中typedef为unsigned int，其值在编译的时候即计算好了，参数可以是数组、指针、类型、对象、函数等，不能返回动态分配的内存空间的大小。 参数 说明 数组 编译时分配的数组空间大小 指针 存储该指针所用的空间大小 类型 该类型所占的空间大小 对象 对象的时间占用空间大小 函数 函数的返回类型所占空间大小，函数的返回类型不能为void strlen()是函数，要在运行时才能计算，参数必须是字符型指针。该函数的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符’\\0’，返回的长度不包括’\\0’。strlen()是通过”\\0”判断字符窜结束的。int data[]={1,2,3,4},其长度计算为sizeof(data)/sizeof(data[0])。 sizeof()和strlen()相关实例说明 字符串 sizeof()大小 strlen()大小 说明 char str[]=”12345” 5 6 系统会自动在字符串的末尾加上字符串结束符’\\0’ char str[]={“12345”} 5 6 系统会自动在字符串的末尾加上字符串结束符’\\0’ char str[10]={‘1’,’2’,’3’,’4’,’5’} 5 10 系统从未初始化的元素开始，将之后的元素加上字符串结束符’\\0’ char str[]={‘1’,’2’,’3’,’4’,’5’} 不确定 5 系统不会自动在字符串的末尾加上字符串结束符’\\0’ char str[]={‘1’,’2’,’\\0’,’4’,’5’} 5 2 strlen()是通过”\\0”判断字符串结束的 char str[]=”ab\\0de” 6 2 strlen()是通过”\\0”判断字符窜结束的 char str[]=”12\\034” 4 3 \\034当做八进制处理，则[0]=&gt;49,’1’;[1]=&gt;50,’2’;[2]=&gt;28,’\\x1c’;[3]=&gt;0,’\\0’ 2.数组指针和指针数组 int (*p)[10]（数组指针）定义一个指针，这个指针指向一个三维数组，指向数组的指针，其本质为指针。 int *p[10]（指针数组，指向int型）定义了一个三维数组，其中每个元素p[0],p[1],…,p[10]都是指向int变量的指针。sizeof(p)=10x4=40。 123int a[2][3]=&#123;3,4,5,6,7,8&#125;;int (*q)[3];q=a; 参数 说明 *(q+i)+j 二维数组的i行j列的地址 (a[i]+j)或a[i][j]或(*(q+i)+j) 是二维数组i行j列的值 a 指向这块连续空间的首地址，值为&amp;a[0][0] a[i] 一维数组名，类型是指向整型的指针，值是&amp;a[i][0],这个值为常量 *(a+i) 取出第i行的首地址 **(a+i) 取出第i行的第一个元素的值 p 一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]，可执行p++,p=a等操作 p+i 同a+i 3.结构体大小/类的大小/Union大小（1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）；（2）结构体的大小必须是所有成员大小的整数倍。 1234567891011class A&#123; class B&#123; class C&#123; class D&#123; class E&#123; class F&#123;public: public: public: public: public: public: int a; double a; &#125;; void print()&#123;&#125; virtual void print()&#123;&#125; F(); short b; short b; &#125;; &#125;; ~F(); int c; int c; &#125;; char d; char d; int func(); int func(); static int e;&#125;; &#125;;sizeof(A)=16; sizeof(B)=24; sizeof(C)=1; sizeof(D)=1; sizeof(E)=4; sizoef(F)=1 空类型的实例中不包含任何的信息，本来求sizeof应该为0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用内存的多少，由编译器决定，Visual Studio中每个空类型的实例占用1个字节的空间。调用构造函数和析构函数只需要知道函数的地质即可，而这些函数的地址只与类型相关，而与内型的实例无关，编译器不会因为这两个函数在实例内添加额外的信息。类的大小只与非静态和虚函数的大小有关。 1234567Union A&#123; Union B&#123; Union C&#123; Union D&#123; char a[10]; double a; char a[13]; char a[13]; short b[4][5]; int b; int b; cahr b; long c[5]; &#125;; &#125;; &#125;; &#125;;sizeof(A)=40; sizeof(B)=8; sizeof(C)=16; sizeof(D)=13 Union变量所占用的内存大小为成员变量中所占空间最大的那个变量的字节数整数倍，共用体表示几个变量共用一个内存变量，在不同的时间保存不同的数据类型和不同长度的变量，在Union中所有的共用体成员共用一个空间，并且同一时间只能存储一个成员变量的值。 4.派生类基类(子类/父类)子类复制父类全部成员。每一个类都有它自己的成员变量和成员函数，是一个独立的空间整体。当子类继承父类时，会将父类的全部成员复制一份，作为子类的成员，但是同时也会标记这些成员是从父类中继承的，与子类的本身有所区别的。 成员函数被重载的特征。（1）相同的范围（同一个类中）（2）函数的名字相同（3）参数不同（4）virtual关键字可有可无函数重载的变名机制：作用域+返回类型+函数名+参数列表。 隐藏：子类对象优先考虑子类域自身成员（成员变量和成员函数）。隐藏发生的主要原因：就是当子类有父类的同名成员时，子类对象访问成员时，会发生冲突。所以编译器的处理方式是优先考虑子类中的自身成员。即子类对象访问某成员时（成员变量和成员函数都一样）编译器首先在子类域中检索。如果在子类域中找到该成员，则检索结束，返回该成员进行访问。如果子类中找不到该成员，则去父类域中检索，如果父类域中存在，则返回该成员进行访问，如果父类域中不存在，则编译错误，该成员无效。隐藏发生的条件：（1）如果派生类的函数与基类的函数同名，但是参数不同，此时无论有无virtual关键字，基类的函数将被隐藏。（2）如果派生类的函数与基类的函数同名，参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏。 覆盖：虚函数，成员函数类型一模一样，父类指针调用子类对象成员。（1）不同的范围（分别位于派生类与基类）（2）函数名字相同（3）参数相同（4）基类函数必须有关键字virtual 5.枚举型枚举值是常量，不是变量。不能在程序中用赋值语句对其进行赋值。枚举元素本身由系统定义了一个表示序号的数值。从0开始顺序定义为0,1,2……,只能把枚举值赋予给枚举变量，不能把元素的数值直接赋值枚举变量。枚举类型的后一个元素在不赋值的情况下比前一个元素大1。 1234enum list&#123;x1,x2,x3,x4=6,x5,x6&#125;; // x2=1, x6=8enum &#123;a,b=5,c,d=4,e&#125;k;k=c; //k的值为6k=e; //k的值为5 6.构造函数/析构函数/拷贝构造函数 构造函数构造函数是实现数据成员初始化的特殊成员函数；构造函数与类名相同，没有类型，也没有返回值；创建对象，构造函数被自动调用；当用户没有定义构造函数时，编译器自动生成一个构造函数；构造函数可以重载，不能为虚函数。 析构函数析构函数用于撤销对象的成员函数，析构函数没有返回值，析构函数不能被重载，可以为虚函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243class CExample &#123; private: int a; public: //构造函数 CExample(int b) &#123; a = b; cout&lt;&lt;\"CExample(int b)\"&lt;&lt;endl; &#125; //拷贝构造函数 CExample(const CExample&amp; C) &#123; a = C.a; cout&lt;&lt;\"CExample(const CExample&amp; C)\"&lt;&lt;endl; &#125; //一般函数 void Show () &#123; cout&lt;&lt;a&lt;&lt;endl; &#125; //析构函数 ~CExample() &#123; cout&lt;&lt;\"~CExample()\"&lt;&lt;endl; &#125; &#125;; int main() &#123; CExample A(100); CExample B = A; // CExample B(A); 也是一样的 B.Show (); return 0; &#125; 结果：CExample(int b)CExample(const CExample&amp; C)100 拷贝构造函数调用的时机（1）当用类的一个对象去初始化该类的另一个对象，系统自动调用拷贝构造函数实现拷贝赋值（2）若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数（对象以值传递的方式传入函数参数）（3）当函数返回值是类的对象的时，系统自动调用拷贝构造函数（对象以值传递的方式从函数返回） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class CExample &#123; private: int a; public: //构造函数 CExample(int b) &#123; a = b; cout&lt;&lt;\"CExample(int b)\"&lt;&lt;endl; &#125; //拷贝构造函数 CExample(const CExample&amp; C) &#123; a = C.a; cout&lt;&lt;\"CExample(const CExample&amp; C)\"&lt;&lt;endl; &#125; //一般函数 void Show () &#123; cout&lt;&lt;a&lt;&lt;endl; &#125; //析构函数 ~CExample() &#123; cout&lt;&lt;\"~CExample()\"&lt;&lt;endl; &#125; &#125;; //(2)对象以值传递的方式传入函数参数 //调用g_Fun()时，会产生以下几个重要步骤：//1.A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。//2.然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);//3.等g_Fun()执行完后, 析构掉 C 对象。void g_Fun(CExample C) &#123; cout&lt;&lt;\"g_Fun(CExample C)\"&lt;&lt;endl; &#125; //(3)对象以值传递的方式从函数返回 //当m_Fun()执行到return时，会产生以下几个重要步骤：//1.先产生一个临时变量，就叫 C 吧。//2.然后调用拷贝构造函数把temp的值给C。 整个这两个步骤有点像：CExample C(temp);//3.在函数执行到最后先析构temp局部变量//3.等g_Fun()执行完后, 析构掉 C 对象。CExample m_Fun() &#123; CExample temp(0); return temp; &#125; int main() &#123; CExample A(100); CExample B = A; // CExample B(A); 也是一样的 g_Fun(A); m_Fun(); return 0; &#125; 结果：CExample(int b)CExample(const CExample&amp; C)CExample(const CExample&amp; C)g_Fun(CExample C)~CExample()CExample(int b)CExample(const CExample&amp; C)~CExample()~CExample() 在构造中需要初始化列表初始化的有三种情况（1）带有const修饰的类成员，如const int a，static const 不需初始化列表中。 12int A::n = 5; //static成员必须在类外初始化，此时不用加关键字static，但是要指定类作用域 A::const int A::p = 30; //static const成员跟static成员一样在类外初始化（而不是在构造函数初始化列表中），记得加上关键字const （2）引用成员数据，如int &amp;p（3）带有引用的类变量 12345678910111213141516171819202122232425262728class Base&#123; public: Base(int &amp;v) : i(v), p(v), j(v) &#123;&#125; void print_val() &#123; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;&#125; private: const int i; //类成员为const类型 int p; int &amp;j; //类成员为引用类型&#125;;class A&#123; public: A(int v) : p(v), b(v) &#123;&#125; void print_val() &#123; cout &lt;&lt; p &lt;&lt; endl;&#125; private: int p; Base b;&#125;;int main(int argc ,char **argv)&#123; int pp = 45; A b(pp); b.print_val(); system(\"pause\"); return 0;&#125; 参考：sizeof与strlen的区别数组指针和指针数组的区别面向对象中的重载、覆盖和隐藏C++拷贝构造函数详解","categories":[{"name":"学习","slug":"学习","permalink":"http://flame160.git.io/categories/学习/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://flame160.git.io/tags/c/"}]},{"title":"网页前端技术","slug":"网页前端技术","date":"2017-03-09T12:33:37.000Z","updated":"2018-03-29T11:50:37.185Z","comments":true,"path":"2017/03/09/网页前端技术/","link":"","permalink":"http://flame160.git.io/2017/03/09/网页前端技术/","excerpt":"HTML是网页的核心，是一种制作万维网页面的标准语言，是万维网浏览器使用的一种语言，它消除了不同计算机之间信息交流的障碍。CSS是层叠样式表，CSS可以帮助把网页外观做得更加美观，是网页前端制作重要的组成部分。JavaScript是一种可以被浏览器解析的解释型脚本语言，使网页显示动态效果并实现与用户交互功能。","text":"HTML是网页的核心，是一种制作万维网页面的标准语言，是万维网浏览器使用的一种语言，它消除了不同计算机之间信息交流的障碍。CSS是层叠样式表，CSS可以帮助把网页外观做得更加美观，是网页前端制作重要的组成部分。JavaScript是一种可以被浏览器解析的解释型脚本语言，使网页显示动态效果并实现与用户交互功能。 HTML-head meta元素可以提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词。 必要的属性 属性 值 描述 content some_text 定义与http-equiv 或 name属性相关的元信息 可选的属性 属性 值 描述 http-equiv content-ty expires 把 content 属性关联到 HTTP 头部。 name author keywords 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 head其它元素 除了meta，head中还包含link, script, title等信息。 属性 作用 使用方式 其它 link 外部样式表 &lt; link rel=”stylesheet” type=”text/css” href=”./css/style.css” &gt; 其它两种样式为：（1）行间样式表；（2）内部样式表 link 网站图标 &lt; link rel=”shortcut icon” href=”./images/logo.icon”&gt; link其它属性参考w3school;图标下载：easyicon和iconpng script 导入js文件 &lt; script type=”text/javascript” src=”./js/jquery.js”&gt;&lt;/ script&gt; script其它属性参考w3school title 网站标题 &lt; title&gt;标题&lt;/ title&gt; 无 HTML-插件 toastmessagetoastmeaasge是一个消息提醒的插件，其主页为jquery-toastmessage-plugin。 第一步：引入需要的文件12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/jquery.toastmessage.css\"&gt;&lt;script type=\"text/javascript\" src=\"./js/jquery.toastmessage.js\"&gt;&lt;/script&gt; 第二步：具体使用123$().toastmessage('showSuccessToast', \"Success Dialog which is fading away ...\");$().toastmessage('showNoticeToast', \"Notice Dialog which is fading away ...\");$().toastmessage('showErrorToast', \"Error Dialog which is fading away ...\"); 12345678$().toastmessage('showToast',&#123; text: 'Success Dialog which is fading', stick: true, position: 'top-right', type: 'success', closeText: '', close: function()&#123;console.log(\"toast is close...\");&#125;&#125;) Highcharts和EchartsHighcharts和Echarts都为图标插件，提供丰富的图表类型，线图、柱形图、饼图、散点图、仪表图、地图等。 UEditorUEditor是由百度「FEX前端研发团队」开发的所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。常用的还有CKEditor、TinyMCE、HTMLArea等。 bootstrap-datetimepickerbootstrap-datetimepicker是时间日期控件。具体使用参考下载后示例sample in bootstrap v2和sample in bootstrap v3。 dropzonedropzone是一个开源的文件拖拽上传插件，提供Ajax异步上传功能，可以一次性上传多个文件，如果是图片可以预览。 Font AwesomeFont AwesomeFont Awesome 字体提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。 前端框架Bootstrap是一个用于快速开发Web应用和网站的前端框架,其响应式CSS能够自适应平板、手机、电脑等设备。amaze UI中国首个开源HTML5跨屏前端框架。 表格控件jqGrid是一个Ajaxed jQuery Grid插件。提供分页功能，添加、编辑、删除和搜索表中记录，支持多种数据类型输入：XML，JSON，Array等，多行选择，支持子表格，集成日期选择控件等等。数据网格（datagrid）以表格格式显示数据，并为选择、排序、分组和编辑数据提供了丰富的支持。","categories":[{"name":"学习","slug":"学习","permalink":"http://flame160.git.io/categories/学习/"}],"tags":[{"name":"网页前端","slug":"网页前端","permalink":"http://flame160.git.io/tags/网页前端/"}]},{"title":"码云和Github","slug":"码云和Github","date":"2017-01-07T07:28:07.000Z","updated":"2018-03-29T11:59:24.609Z","comments":true,"path":"2017/01/07/码云和Github/","link":"","permalink":"http://flame160.git.io/2017/01/07/码云和Github/","excerpt":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。码云和Github都是代码托管平台，码云是开源中国社区2013年推出的基于 Git 的完全免费的代码托管服务，这个服务是基于 Gitlab 开源软件所开发的。码云相对于Github服务器在国内，速度更快，但是有时不稳定。码云的免费账户可以建立私有项目，Github的私有项目需要付费。","text":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。码云和Github都是代码托管平台，码云是开源中国社区2013年推出的基于 Git 的完全免费的代码托管服务，这个服务是基于 Gitlab 开源软件所开发的。码云相对于Github服务器在国内，速度更快，但是有时不稳定。码云的免费账户可以建立私有项目，Github的私有项目需要付费。 1.码云 Clone1git clone http://git.oschina.net/xxxx/xxxx.git 例如:123git clone http://git.oschina.net/flame160/Test.gitflame160为oschina的用户名Test新建的项目名 写代码，提交变更12git add .git commit -m \"注释\" 或者将上面两句合并成一句1git commit -am \"注释\" 修改注释 123git commit --amend //进行文本进行注释修改然后保存文本git commit --amend -m \"新的注释\"git push -f push 1git push 或者 git push origin $name (git push origin $Test) git版本恢复命令 123git reset --mixed： //此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset --soft： //回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可git reset --hard： //彻底回退到某个版本，本地的源码也会变为上一个版本的内容 例如：123git rest --hard HEAD^ //回退所有内容到上一个版本 git reset --soft HEAD~3 //回退到第3个版本 git reset 78eb6959c //回退到某个版本（commits 78eb6959c ） 用git reset –hard HEAD^^ 回退到前两版本后,再在此版本上更新后,想push,但出错,提示说remote端的版本比我本地版本要高。 解决办法：这种“回退”就是在否认历史，如果有其他人也在用你的remote，你push以后将他置于何地呢？所以，如果仅仅你自己在使用，那么强制push，命令是git push -f 如果是与人合作，更漂亮的做法是revert。git revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留git reset 是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区 git revert 撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交123git revert HEAD^ //撤销前前一次 commitgit revert commit //（比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。 git其它常用命令 命令 说明 git branch 查看本地所有分支 git status 查看当前状态 git log 查看提交历史 git show 显示某次提交的内容 Git@可以结合Team@OSC来更好的进行团队开发，实现开发团队的代码变动状态，任务管理，在线多人编写技术文档，讨论分享等。 2.Github码云是仿照Github的，因此两者的使用非常类似。其具体安装配置及相关功能使用参考博客[1]和[2]。 Clone12git clone git@github.com:xxx/xxx.gitgit clone git@github.com:flame60/MyTest.git 写代码、提交变更、注释与码云相同，版本回退也相同，除此之外，还可以打开Github For Windows进入到需要回退的项目主页，在History里选中要回退的某个版本，点击右侧的“roll back”按钮，这时在下方就会提示一个“UNDO”的撤销操作，代表你已经成功回退到某个版本了。 push1git push -u origin master 参考：Git 常用命令速查表(图文+表格)git如何修改注释Git版本恢复命令resetgit 回退到某版本后,再在此版本上更新,无法push","categories":[{"name":"工具","slug":"工具","permalink":"http://flame160.git.io/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"http://flame160.git.io/tags/git/"}]},{"title":"数组字符串相关算法","slug":"数组字符串相关算法","date":"2016-11-30T06:37:15.000Z","updated":"2018-03-29T11:23:34.977Z","comments":true,"path":"2016/11/30/数组字符串相关算法/","link":"","permalink":"http://flame160.git.io/2016/11/30/数组字符串相关算法/","excerpt":"数组字符串相关的经典算法：1.最大连续子序列和（Maximum Subarray） 2.最长递增子序列（Longest Increasing Subsequence）3.最长公共子串（Longest Common Substirng） 4.最长公共子序列（Longest Common Subsequence）5.字符串编辑距离（Edit Distance） 6.最长不重复字串（Longest Substring Without Repeating Characters）7.最长回文子串（Longest Palindromic Substring） 8.最长公共前缀（Longest Common Prefix）9.两个排序数组的中位数（Median of Two Sorted Arrays）","text":"数组字符串相关的经典算法：1.最大连续子序列和（Maximum Subarray） 2.最长递增子序列（Longest Increasing Subsequence）3.最长公共子串（Longest Common Substirng） 4.最长公共子序列（Longest Common Subsequence）5.字符串编辑距离（Edit Distance） 6.最长不重复字串（Longest Substring Without Repeating Characters）7.最长回文子串（Longest Palindromic Substring） 8.最长公共前缀（Longest Common Prefix）9.两个排序数组的中位数（Median of Two Sorted Arrays） 1.最大连续子序列和题目的目的是要找出由数组成的一维数组中和最大的连续子序列。比如[0，-2，3，5，-1，2]应返回9，[-9，-2，-3，-5，-3]应返回-2。题目连接：LeetCode 53 Maximum Subarray。 思路：采用动态规划的思想，设状态f[j]表示以S[j]结尾的最大连续子序列和，则状态转移方程如下：\\begin{equation}f[j]=max\\{f[j-1]+S[j],S[j]\\}, 其中1&lt;=j&lt;=n \\\\target=max\\{f[j]\\}, 其中1&lt;=j&lt;=n\\end{equation} 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int max = INT_MIN; int sum = INT_MIN; for(int i=0;i&lt;nums.size();i++) &#123; sum=sum&lt;0?nums[i]:nums[i]+sum; if(sum&gt;max) max=sum; &#125; return max; &#125;&#125;;int main()&#123; Solution solution; vector&lt;int&gt; vec(6); vec[0]=0;vec[1]=-2;vec[2]=3; vec[3]=5;vec[4]=-1;vec[5]=2; cout&lt;&lt;solution.maxSubArray(vec)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 2.最长递增子序列给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。样例 给出[5,4,1,2,3]，这个LIS是[1,2,3]，返回 3。给出[4,2,4,5,3,7]，这个LIS是[4,4,5,7]，返回 4。题目连接：LeetCode 300 Longest Increasing Subsequence。 思路：本题采用动态规划的思想，其中dp[i]表示以nums[i]结尾的最长递增子串的长度，对于每一个nums[i],我们从第一个数搜索到i,如果发现某个数小于nums[i],则更新dp[i],更新方法为$dp[i]=max(dp[i],dp[j]+1)$,到最后dp数据中最大的值就是我们要返回的LIS长度。时间复杂度为$O(n^2)$,为了进一步优化，我们可以采用动态规划和二分查找相结合，具体参考Grandyang博客和寒小阳CSDN,其时间复杂度为$O(nlogn)$。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;1)return 0; int *dp = new int[nums.size()]; int res=1; for(int i=0;i&lt;nums.size();i++) &#123; dp[i]=1; for(int j=0;j&lt;i;j++) &#123; if(nums[i]&gt;nums[j]) dp[i]=max(dp[i],dp[j]+1); &#125; res=max(res,dp[i]); &#125; delete[] dp; return res; &#125;&#125;;int main()&#123; Solution solution; vector&lt;int&gt; vec(6); vec[0]=4;vec[1]=2;vec[2]=4; vec[3]=5;vec[4]=3;vec[5]=7; cout&lt;&lt;solution.lengthOfLIS(vec)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 3.最长公共子串给定两个字符串，求它们的最长公共子串(Longest Common Substirng),并且要求在原字符串中是连续的。 思路：采用动态规划，用二维数组c[i][j]表示$(x_1,x_2,…,x_m)$与$(y_1,y_2,…,y_n)$中以$x_i$和$y_j$结尾的最长公共字符串的长度。则可得到状态转移方程： 最长公共子串的长度为$max(c[i,j]),i \\in \\{ 1,2,..m\\},j \\in \\{ 1,2,..n\\}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;malloc.h&gt;#include&lt;string&gt;using namespace std;class Solution &#123;public: int LCS(string str1, string str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int res=0; if(len1&lt;=0 || len2&lt;=0)return res; int **c=new int *[len1+1]; //int **c=(int**)malloc(sizeof(int*)*len1); for(int i=0;i&lt;=len1;i++) &#123; c[i]=new int[len2+1]; &#125; for (int i = 0; i &lt;= len1; i++) &#123; for( int j = 0; j &lt;= len2; j++) &#123; if(i == 0 || j == 0) &#123; c[i][j] = 0; &#125; else if (str1[i] == str2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; res=max(c[i][j],res); &#125; else &#123; c[i][j] = 0; &#125; &#125; &#125; for(int i=0;i&lt;=len1;i++) &#123; delete[] c[i]; &#125; delete[] c; return res; &#125;&#125;;int main()&#123; Solution solution; string str1(\"abcaba\"); string str2(\"acbaa\"); cout&lt;&lt;solution.LCS(str1,str2)&lt;&lt;endl; system(\"pause\"); return 0; &#125; 4.最长公共子序列给定两个字符串，求它们的最长公共子序列(Longest Common Subsequence),与题3不同的是，其中子序列在原字符串中不要求是连续的。 思路：采用动态规划，用二维数组c[i][j]表示$(x_1,x_2,…,x_n)$与$(y_1,y_2,…,y_n)$中以$x_i$和$y_j$结尾的最长公共字符串的长度。则可得到状态转移方程： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;#define MAXN 1005char a[MAXN],b[MAXN];char c[MAXN][MAXN];int LCSS(int i,int j)&#123; if(i==0|| j==0)return 0;//停止条件 if(a[i]==b[j]) return c[i][j]=LCSS(i-1,j-1)+1; else return c[i][j]=LCSS(i-1,j)&gt;LCSS(i,j-1)?LCSS(i-1,j):LCSS(i,j-1);&#125;int main()&#123; //while(scanf(\"%s%s\", &amp;a, &amp;b) != EOF) //scanf遇空格停止。 while(gets(a) &amp;&amp; gets(b)) &#123; printf(\"%d\\n\",LCSS(strlen(a),strlen(b))); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;malloc.h&gt;#include&lt;string&gt;using namespace std;class Solution &#123;public: int LCS(string str1, string str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int res=0; if(len1&lt;=0 || len2&lt;=0)return res; int **c=new int *[len1+1]; //int **c=(int**)malloc(sizeof(int*)*len1); for(int i=0;i&lt;=len1;i++) &#123; c[i]=new int[len2+1]; &#125; for (int i = 0; i &lt;= len1; i++) &#123; for( int j = 0; j &lt;= len2; j++) &#123; if(i == 0 || j == 0) &#123; c[i][j] = 0; &#125; else if (str1[i] == str2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; &#125; else &#123; c[i][j] = max(c[i - 1][j], c[i][j - 1]); &#125; &#125; &#125; res=c[len1][len2]; for(int i=0;i&lt;=len1;i++) &#123; delete[] c[i]; &#125; delete[] c; return res; &#125;&#125;;int main()&#123; Solution solution; string str1(\"acaaba\"); string str2(\"acbaa\"); cout&lt;&lt;solution.LCS(str1,str2)&lt;&lt;endl; system(\"pause\"); return 0; &#125; 5.字符串编辑距离字符串编辑距离是指利用字符操作，把字符串A转换成字符串B所需要的最少操作数。其中，字符操作包括： 删除一个字符 a) Insert a character 插入一个字符 b) Delete a character 修改一个字符 c) Replace a character 例如对于字符串”if”和”iff”，可以通过插入一个’f’或者删除一个’f’来达到目的。题目连接：LeetCode 72 Edit Distance。 思路：用edit[i][j]表示A串和B串的编辑距离。edit[i][j]表示A串从第0个字符开始到第i个字符和B串从第0个字符开始到第j个字符，这两个字串的编辑距离。字符串的下标从1开始。dis[0][0]表示word1和word2都为空的时候，此时他们的Edit Distance为0。很明显可以得出的，dis[0][j]就是word1为空，word2长度为j的情况，此时他们的Edit Distance为j，也就是从空，添加j个字符转换成word2的最小Edit Distance为j；同理dis[i][0]就是，word1长度为i，word2为空时，word1需要删除i个字符才能转换成空，所以转换成word2的最小Edit Distance为i。 动态规划方程为： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int minDistance(string word1, string word2) &#123; int row = word1.length() + 1; int col = word2.length() + 1; vector&lt;vector&lt;int&gt;&gt; f(row, vector&lt;int&gt;(col)); for (int i = 0; i &lt; row; i++) f[i][0] = i; for (int j = 0; j &lt; col; j++) f[0][j] = j; for (int i = 1; i &lt; row; i++) for (int j = 1; j &lt; col; j++)&#123; int flag=word1[i-1]==word2[j-1]?0:1; f[i][j] = min(f[i-1][j-1]+flag, min(f[i-1][j]+1, f[i][j-1]+1)); &#125; return f[row-1][col-1]; &#125;&#125;;int main()&#123; Solution solution; string str1(\"ab\"); string str2(\"b\"); cout&lt;&lt;solution.minDistance(str1,str2)&lt;&lt;endl; system(\"pause\"); return 0; &#125; 6.最长不重复字串给定一个字符串，请找出其中无重复字符的最长子字符串。例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。对于，”bbbbb”,其无重复字符的最长子字符串为”b”，长度为1。题目连接：LeetCode 3 Longest Substring Without Repeating Characters。 思路：利用一个vector table保存字符是否出现，从前向后遍历数组，如果遇到已存在的字符，则回退到这个字符上次出现的位置下一位，重新开始统计，table同步更新。如下图所示。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;class Solution&#123;public : int lengthOfLongestSubstring(string s) &#123; if(s.length()==0) &#123; return 0; &#125; int start=0,result=0; vector&lt;int&gt; table(256,-1);//初始都为-1 for(int i=0;i&lt;s.length();i++) &#123; if(table[s[i]]&gt;=start) start=table[s[i]]+1;//每一个过程开始时的位置 result=max(result,i-start+1); table[s[i]]=i; &#125; return result; &#125;&#125;;int main()&#123; Solution solution; string s=\"qpxrjxkltzyx\"; cout&lt;&lt;solution.lengthOfLongestSubstring(s)&lt;&lt;endl; system(\"pause\");&#125; 7.最长回文子串给出一个字符串s，找到一个最长的连续回文串。例如,字符串 babcbabcbaccba 最长回文是:abcbabcba。题目连接：LeetCode 5 Longest Palindromic Substring。 思路：采用动态规划，假设dp[ i ][ j ]的值为true，表示字符串s中下标从 i 到 j 的字符组成的子串是回文串。则dp[i][j]=dp[i + 1][j - 1] &amp;&amp; s[i]==s[j]。当s[i]!=s[j]的时候，dp[i][j]直接就是false。时间复杂度为$O(n^2)$,为了进一步优化，我们可以manacher算法，可以参考文西CSDN和Longest Palindromic Substring Part II，其时间复杂度为$O(n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Solution &#123;public: string longestPalindrome(string s) &#123; int len=s.length(); int max=1,ss=0,tt=0,i,j; bool **flag=new bool*[len]; for(i=0;i&lt;len;i++) &#123; flag[i]=new bool[len]; &#125; for(i=0;i&lt;len;i++) for(j=0;j&lt;len;j++) if(i&gt;=j)flag[i][j]=true; else flag[i][j]=false; for(j=1;j&lt;len;j++) for(i=0;i&lt;j;i++) &#123; if(s[i]==s[j]) &#123; flag[i][j]=flag[i+1][j-1]; if(flag[i][j]==true&amp;&amp;j-i+1&gt;max) &#123; max=j-i+1; ss=i; tt=j; &#125; &#125; else flag[i][j]=false; &#125; for(i=0;i&lt;len;i++) delete flag[i]; delete[] flag; return s.substr(ss,max); &#125;&#125;;int main()&#123; Solution solution; string s=\"abbac\"; cout&lt;&lt;solution.longestPalindrome(s)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 8.最长公共前缀找出所有字符串的最长公共前缀。题目连接：LeetCode 14 Longest Common Prefix。 思路：字符串的最长公共前缀，其长度肯定不会超过最短的字符串的长度。首先取第一个字符串为prefix，然后遍历该prefix，并且判断每个字符串对应的位置对应的值是否相等和其索引是否已经大于其它字符串的长度。返回满足条件的公共字符串。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int n=strs.size(); if(n==0)return \"\"; string prefix=strs[0]; for(int i=0;i&lt;prefix.length();i++)&#123; for(int j=1;j&lt;n;j++) if(i&gt;strs[j].length()||prefix[i]!=strs[j][i]) return prefix.substr(0,i); &#125; return prefix; &#125;&#125;;int main()&#123; Solution solution; vector&lt;string&gt; strs(3); strs[0]=\"abc\"; strs[1]=\"abgd\"; strs[2]=\"abdf\"; cout&lt;&lt;solution.longestCommonPrefix(strs)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 9.两个排序数组的中位数题目连接：LeetCode 4 Median of Two Sorted Arrays 合并后求Medium:时间复杂度为O(nlogn),先将两个排序好的数组合并，然后求其中位数。该方法比较容易想到，但是时间效率不高。 12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; double result; int m=nums1.size(); int n=nums2.size(); nums1.insert(nums1.end(),nums2.begin(),nums2.end()); sort(nums1.begin(),nums1.end()); if((m+n)%2==0) &#123; result=(nums1[(m+n)/2-1]+nums1[(m+n)/2])/2.0; &#125; else &#123; result=nums1[(m+n)/2]*1.0; &#125; return result; &#125;&#125;; 二分的思想:时间复杂度为O(log (m+n)),思路相对复杂，问题转换为寻找求k小的数，不需要对两个数组进行合并。实现具体过程参考yutianzuijin博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;malloc.h&gt;#include&lt;algorithm&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m=nums1.size(); int n=nums2.size(); int total=m+n; int* num1=NULL; int* num2=NULL; if(m&gt;0) num1 = (int*) malloc(m*sizeof(int)); for(int i=0; i&lt;m; i++) num1[i] = nums1[i]; if(n&gt;0) num2 = (int*) malloc(n*sizeof(int)); for(int j=0; j&lt;n; j++) num2[j] = nums2[j]; if(total%2!=0) &#123; return findKth(num1,m,num2,n,total/2+1); &#125; else &#123; return (findKth(num1,m,num2,n,total/2)+findKth(num1,m,num2,n,total/2+1))/2.0; &#125; &#125; double findKth(int* nums1,int m,int *nums2,int n,int k) &#123; if(m&gt;n) return findKth(nums2,n,nums1,m,k)*1.0; if(m==0) return nums2[k-1]; if(k==1) return min(nums1[0],nums2[0]); int pa=min(k/2,m); int pb=k-pa; if(nums1[pa-1]&lt;nums2[pb-1]) return findKth(nums1+pa, m - pa, nums2, n, k - pa); else if(nums1[pa-1]&gt;nums2[pb-1]) return findKth(nums1,m,nums2+pb,n-pb,k-pb); else return nums1[pa - 1]; &#125;&#125;;int main()&#123; Solution solution; vector&lt;int&gt;nums1(3); vector&lt;int&gt;nums2(4); nums1[0]=1;nums1[1]=2;nums1[2]=3; nums2[0]=6;nums2[1]=7;nums2[2]=8;nums2[3]=9; cout&lt;&lt;solution.findMedianSortedArrays(nums1,nums2)&lt;&lt;endl; system(\"pause\"); return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://flame160.git.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://flame160.git.io/tags/c/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://flame160.git.io/tags/LeetCode/"}]},{"title":"LeetCode算法题","slug":"LeetCode算法题","date":"2016-03-15T11:29:50.000Z","updated":"2018-03-29T10:32:47.894Z","comments":true,"path":"2016/03/15/LeetCode算法题/","link":"","permalink":"http://flame160.git.io/2016/03/15/LeetCode算法题/","excerpt":"在找工作之前，一般会将c/c++，数据结构等知识复习一遍，同时也会找一些比较经典的面试题目学习。根据师兄师姐的介绍选择在LeetCode上进行相关算法的复习，维持一种编程状态，本篇博客介绍以下几种算法。1.Two Sum:给定一个整数数组，找出其中两个数满足相加等于你指定的目标数字。2.Add Two Numbers:给两个链表代表两个反向存储的数字,返回他们的和,用链表表示。3.Add Digits:给定一个非负整数num,重复地将其每位数字相加，直到结果只有一位数为止。4.Happy Number:题目要求对任意一个正整数，不断各个数位上数字的平方和,若最终收敛为1,则该数字为happy number,否则程序可能从某个数开始陷入循环。5.打印1到最大的n位数。","text":"在找工作之前，一般会将c/c++，数据结构等知识复习一遍，同时也会找一些比较经典的面试题目学习。根据师兄师姐的介绍选择在LeetCode上进行相关算法的复习，维持一种编程状态，本篇博客介绍以下几种算法。1.Two Sum:给定一个整数数组，找出其中两个数满足相加等于你指定的目标数字。2.Add Two Numbers:给两个链表代表两个反向存储的数字,返回他们的和,用链表表示。3.Add Digits:给定一个非负整数num,重复地将其每位数字相加，直到结果只有一位数为止。4.Happy Number:题目要求对任意一个正整数，不断各个数位上数字的平方和,若最终收敛为1,则该数字为happy number,否则程序可能从某个数开始陷入循环。5.打印1到最大的n位数。 1.Two Sum题目连接:https://leetcode-cn.com/problems/two-sum/description/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 看到题目首先想到的是通过两层循环进行暴力查找，但是这并不是面试官或者出题人本身想要看到的结果，人们更倾向于看到时间复杂度更低的算法。经过分析可以采用下面两种算法： 排序后查找:首先将数组进行排序，然后两个指针分别指向排序后数组的首端和末端，如果对应的数相加小于给定的数target，则首端指针后移一位；如果对应的数相加大于给定的数target，则末端指针前移一位；如果相等则返回结果(Index 存储在vector)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Node&#123; int num,pos;&#125;;bool cmp(Node a,Node b)&#123; return a.num&lt;b.num;&#125;class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp;nums,int target)&#123; vector&lt;int&gt; result; vector&lt;Node&gt; array; for(int i=0;i&lt;nums.size();i++) &#123; Node temp; temp.num=nums[i]; temp.pos=i; array.push_back(temp); &#125; sort(array.begin(),array.end(),cmp); for(int i=0,j=array.size()-1;i!=j;) &#123; int sum=array[i].num+array[j].num; if(sum==target) &#123; result.push_back(array[i].pos); result.push_back(array[j].pos); break; &#125; else if(sum&lt;target) &#123; i++; &#125; else&#123; j--; &#125; &#125; return result; &#125;&#125;;int main()&#123; Solution S; vector&lt;int&gt; vec;//创建vector对象 vector&lt;int&gt; nums(3); nums[0]=2;nums[1]=7;nums[2]=7; int target=14; vec=S.twoSum(nums,target); vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; vec.clear(); system(\"pause\");&#125; Hash表:将每个数字放在map中，然后历遍数组，如果map中出现和数组中的某一个值相加为target的时候，则break，输出结果。其中要考虑输出结果的两个Index不能相同，即target是数组中某一个数（该数只出现一次）的两倍，不满足要求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp;nums,int target)&#123; vector&lt;int&gt; result; map&lt;int,int&gt; m; //map是模板，一个map变量key和value两个值， //map&lt;int,int&gt; m,m-&gt;first可以取得key值，m-&gt;second可以取得value值； for(int i=0;i&lt;nums.size();i++) &#123; m[nums[i]]=i; &#125; map&lt;int, int&gt;::iterator it; /*for (it = m.begin(); it != m.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; \"=\" &lt;&lt; it-&gt;second &lt;&lt; endl; */ for(int i=0;i&lt;nums.size();i++) &#123; if((it=m.find(target-nums[i]))!=m.end())//m.find(key)：返回迭代器，判断是否存在。 &#123; if(i==it-&gt;second) continue; result.push_back(i); result.push_back(it-&gt;second); break; &#125; &#125; return result; &#125;&#125;;int main()&#123; Solution S; vector&lt;int&gt; vec;//创建vector对象 vector&lt;int&gt; nums(4); nums[0]=2;nums[1]=7;nums[2]=12;nums[3]=13; int target=14; vec=S.twoSum(nums,target); /*for(int i=0;i&lt;vec.size();i++) &#123; cout&lt;&lt;vec[i]&lt;&lt;\" \"; &#125;*/ vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; vec.clear(); system(\"pause\");&#125; 2.Add Two Numbers题目连接:https://leetcode-cn.com/problems/add-two-numbers/description/ You are given two linked lists representing two non-negative numbers.The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 该题需要注意一下几点： 数字存储是反过来存储的，因此我们只需要从两个链表的首端开始遍历； 考虑每次相加后的进位问题; 两个链表的长度不一样，对长链表(实际为多出来的位数)的处理; 当两个链表长度相同时，对最后一位相加的处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;malloc.h&gt;using namespace std;struct ListNode&#123; int val; ListNode *next;&#125;;class Solution&#123;public: ListNode *addTwoNumbers(ListNode *l1,ListNode *l2) &#123; ListNode *head=(ListNode *)malloc(sizeof(ListNode)); ListNode *pre=head; ListNode *node=NULL; int flag=0,sum;//flag进位，sum为两个数的和 while(l1!=NULL &amp;&amp; l2!=NULL) &#123; sum=l1-&gt;val+l2-&gt;val+flag; flag=sum/10; node=(ListNode *)malloc(sizeof(ListNode)); node-&gt;val=sum%10; node-&gt;next=NULL; pre-&gt;next=node; pre=node; l1=l1-&gt;next; l2=l2-&gt;next; &#125; while(l1!=NULL) &#123; sum=l1-&gt;val+flag; flag=sum/10; node = (ListNode *)malloc(sizeof(ListNode)); node-&gt;val = sum % 10; node-&gt;next = NULL; pre-&gt;next = node; pre = node; l1 = l1-&gt;next; &#125; while(l2!=NULL) &#123; sum = l2-&gt;val + flag; flag= sum / 10; node = (ListNode *)malloc(sizeof(ListNode)); node-&gt;val = sum % 10; node-&gt;next = NULL; pre-&gt;next = node; pre = node; l2 = l2-&gt;next; &#125; if(flag&gt;0) &#123; node = (ListNode *)malloc(sizeof(ListNode)); node-&gt;val = flag; node-&gt;next = NULL; pre-&gt;next = node; pre = node; &#125; return head-&gt;next; &#125;&#125;;int main() &#123; Solution solution; int A[] = &#123;2,4,7,9&#125;; int B[] = &#123;5,6,4&#125;; ListNode *head = NULL; ListNode *head1 = (ListNode*)malloc(sizeof(ListNode)); ListNode *head2 = (ListNode*)malloc(sizeof(ListNode)); head1-&gt;next = NULL; head2-&gt;next = NULL; ListNode *node; ListNode *pre = head1; for(int i = 0;i &lt; 4;i++)&#123; node = (ListNode*)malloc(sizeof(ListNode)); node-&gt;val = A[i]; node-&gt;next = NULL; pre-&gt;next = node; pre = node; &#125; pre = head2; for(int i = 0;i &lt; 3;i++)&#123; node = (ListNode*)malloc(sizeof(ListNode)); node-&gt;val = B[i]; node-&gt;next = NULL; pre-&gt;next = node; pre = node; &#125; head = solution.addTwoNumbers(head1-&gt;next,head2-&gt;next); while(head != NULL)&#123; printf(\"%d \",head-&gt;val); head = head-&gt;next; &#125; system(\"pause\"); return 0;&#125; 3.Add Digits题目连接:https://leetcode-cn.com/problems/add-digits/description/ Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 对于任意给定的数字$x$(以三位数为例),$x=100a+10b+c$,其中a,b,c分别为百位,十位和个位。同时$x$可表示为如下： $$x=99a+9b+(a+b+c)$$ 除了a+b=c以外，剩余的一定能被9整除，因此所有位上的和就是求取x%9的结果，但当x能被9整除时，$x\\%9=0$，而正确的结果为9，因此我们可以得到如下表达式: $$sum(n) = 1 + (n-1) \\% 9$$ 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;class Solution &#123;public: int addDigits(int num) &#123; if(num&lt;10)return num; else &#123; return (num - 1) % 9 + 1; &#125; &#125;&#125;;int main()&#123; Solution solution; int num=38; cout&lt;&lt;solution.addDigits(num)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 4.Happy Number题目连接:https://leetcode-cn.com/problems/happy-number/description/ A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number $1^2 + 9^2 = 82$$8^2+ 2^2 = 68$$6^2+ 8^2= 100$$1^2 + 0^2 + 0^2 = 1$ 方法(1):在维基百科Happy number中我们发现从1到10中1,7,10是Happy number，其余的都是non-happy number。所有的non-happy numbers(1,2,…,n)都会达到如下循环: 4,16,37,58,89,145,42,20,4,…… 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;class Solution &#123;public: bool isHappy(int n) &#123; while(n&gt;6)&#123;//2,3,4,5都为non-happy numbers int next = 0; while(n)&#123;next+=(n%10)*(n%10); n/=10;&#125; n = next; &#125; return n==1; &#125;&#125;;int main()&#123; Solution solution; int n=19; cout&lt;&lt;solution.isHappy(n)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 方法(2)我们需要通过一个哈希表存储已经出现过的数字即可。可以采用set集合容器来解决此问题(当然vector,map也可以解决此问题)。每次将其所有位上的平方和结果存储在set里，若结果为1，则是happy number；若出现重复，则是non-happy number。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;class Solution &#123;public: bool isHappy(int n) &#123; if (n &lt; 1) return false; if (n == 1) return true; set&lt;int&gt; showedNums; showedNums.insert(n); while(true) &#123; int s = 0; while(n) &#123; s += (n % 10) * (n % 10); n = n / 10; &#125; if (s == 1) return true; else if (showedNums.find(s) != showedNums.end()) return false; n = s; showedNums.insert(s); &#125; &#125;&#125;;int main()&#123; Solution solution; int n=20; cout&lt;&lt;solution.isHappy(n)&lt;&lt;endl; system(\"pause\"); return 0;&#125; 5.打印1到最大的n位数题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 在字符串上模拟数字加法的解法由于输入n的值不太确定，当n输入很大时，我们求最大n位数是不能通过整型(int)或者长正型(long long int)表示的，因为都会溢出。因此采用字符串表示或者数组表示大数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;bool Increment(char *number)&#123; bool isOverflow=false; int nTakeOver=0; int nLength=strlen(number);//strlen返回的长度不含'\\0' for(int i=nLength-1;i&gt;=0;i--) &#123; int nSum=number[i]-'0'+nTakeOver; if(i==nLength-1) nSum++; if(nSum&gt;=10) &#123; if(i==0) isOverflow=true; else &#123; nSum-=10; nTakeOver=1; number[i]='0'+nSum; &#125; &#125; else &#123; number[i]='0'+nSum; break; &#125; &#125; return isOverflow;&#125;void PrintNumber(char *number)&#123; bool isBeginning0=true; int nLength=strlen(number); for(int i=0;i&lt;nLength;++i) &#123; if(isBeginning0&amp;&amp;number[i]!='0') isBeginning0=false; if(!isBeginning0) &#123; printf(\"%c\",number[i]); &#125; &#125; printf(\"\\t\");&#125;void Print1ToMaxOfNDigits(int n)&#123; if(n&lt;=0)return; char *number=new char[n+1];//字符串末结束符号为'\\0' memset(number,'0',n); number[n]='\\0'; while(!Increment(number)) &#123; PrintNumber(number); &#125; delete []number; &#125;int main()&#123; int n; cin&gt;&gt;n; Print1ToMaxOfNDigits(n); system(\"pause\");&#125; 把问题转换为数字排列的解法把数字的每一位都从0到9排列一遍，就得到了所有的十进制数，全排列采用递归实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void PrintNumber(char *number)&#123; bool isBeginning0=true; int nLength=strlen(number); for(int i=0;i&lt;nLength;++i) &#123; if(isBeginning0&amp;&amp;number[i]!='0') isBeginning0=false; if(!isBeginning0) &#123; printf(\"%c\",number[i]); &#125; &#125; printf(\"\\t\");&#125;void Print1ToMaxOfNDigitsRecursively(char *number,int length,int index)&#123; if(index==length-1) &#123; PrintNumber(number); return; &#125; for(int i=0;i&lt;10;++i) &#123; number[index+1]=i+'0'; Print1ToMaxOfNDigitsRecursively(number,length,index+1); &#125;&#125;void Print1ToMaxOfNDigits(int n)&#123; if(n&lt;=0)return; char *number=new char[n+1]; memset(number,'0',n); number[n]='\\0'; for(int i=0;i&lt;10;i++) &#123; number[0]=i+'0'; Print1ToMaxOfNDigitsRecursively(number,n,0); &#125; delete []number;&#125;int main()&#123; int n; cin&gt;&gt;n; Print1ToMaxOfNDigits(n); system(\"pause\");&#125; n的取值范围题目给出的是数字n，未说明n的取值范围，而上述两种方法中输入的n都为整数，如果n的值超出整型和长整形表示范围后，具体应该如何实现？通过字符串和数组虽然能够表示n，但是n过大时，计算机无法开辟那么大的空间；就算可以开辟，new char[n]其中n如何表示(因为n超出整型或者长整型的表示范围，是一个字符串或者数组)。因此输入的数字n是用整型表示的。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://flame160.git.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://flame160.git.io/tags/c/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://flame160.git.io/tags/LeetCode/"}]},{"title":"Twitter数据情感分析","slug":"Twitter数据情感分析","date":"2015-12-21T13:05:00.000Z","updated":"2018-03-29T08:07:28.600Z","comments":true,"path":"2015/12/21/Twitter数据情感分析/","link":"","permalink":"http://flame160.git.io/2015/12/21/Twitter数据情感分析/","excerpt":"如今，社交已经成为生活必不可少的事情，社交网络(twitter,facebook……)中所包含的数据越来越庞大，如何根据自己的需求去获取相关的数据，进而再从这些数据中进行分析，得到有用的信息。本博客基于twitter社交网络，根据关键字和日期获取与俄罗斯战机在土耳其被击落的相关信息，然后将获得的数据进行sentiment analysis，得到人们关于此事件的正负情绪。","text":"如今，社交已经成为生活必不可少的事情，社交网络(twitter,facebook……)中所包含的数据越来越庞大，如何根据自己的需求去获取相关的数据，进而再从这些数据中进行分析，得到有用的信息。本博客基于twitter社交网络，根据关键字和日期获取与俄罗斯战机在土耳其被击落的相关信息，然后将获得的数据进行sentiment analysis，得到人们关于此事件的正负情绪。 1.获取Twitter数据（1）准备工作 操作系统:linux(ubuntu),当然window也可以，只是没有ubuntu方便。 python安装:最好是安装python2.7版本。 pip安装:通过pip来安装其它包(比apt-get较好)。 tweepy安装:使用tweepy获得twitter数据。 twitter账号申请:首先需要翻墙(vpn或者其它方式)，注册一个twitter账号，但是会遇到一个问题，国内的手机号无法验证（比较无奈:可以利用网上所提供的方法和请求他人帮忙注册），本文利用他人的twitter账号。注册之后需要创建New app,获得Keys和Access Tokens。完成这些，前期准备工作就已经结束了。 （2）数据获取 获取实时数据:利用Twitter Stream API和Python获得twitter实时数据。建立twitter_streaming.py，代码如下。12345678910111213141516171819202122232425262728293031#Import the necessary methods from tweepy libraryfrom tweepy.streaming import StreamListenerfrom tweepy import OAuthHandlerfrom tweepy import Stream#Variables that contains the user credentials to access Twitter API access_token = \"437532854***********hxpcI8gWLTU0p3Cmg6igY\"access_token_secret = \"d3A***********6L3T2thB2ODNND9\"consumer_key = \"VXO*********WnR0eooSNFO\"consumer_secret = \"9ol**********iN7XgV8D67\"#This is a basic listener that just prints received tweets to stdout.class StdOutListener(StreamListener): def on_data(self, data): print data return True def on_error(self, status): print statusif __name__ == '__main__': #This handles Twitter authetification and the connection to Twitter Streaming API l = StdOutListener() auth = OAuthHandler(consumer_key, consumer_secret) auth.set_access_token(access_token, access_token_secret) stream = Stream(auth, l) #This line filter Twitter Streams to capture data by the keywords: 'python', 'javascript', 'ruby' stream.filter(track=['python', 'javascript', 'ruby']) access_token,access_token_secret,consumer_key,consumer_secret即前期准备中(最后一步)你所获得。运行python twitter_streaming.py，便可将结果显示在终端，获得运行python twitter_streaming.py &gt; twitter_data.txt将结果保存在twitter_data.txt文件夹，为json格式，各个key-value代表的意思参考twitter API。 根据关键字和日期获取twitter数据:大多时候我们并不是想要获取所有的twitter信息，而是根据所提供的关键字来获取信息，不过tweepy只能获取前7-10天的信息。12345678910111213141516171819202122232425262728import tweepyimport csvaccess_token = \"4375328544***********8OnhxpcI8gWLTU0p3Cmg6igY\"access_token_secret = \"d3ABl********KtWIDkpo6L3T2thB2ODNND9\"consumer_key = \"VXO*******R0eooSNFO\"consumer_secret = \"9olt*******j9PMKN7CnT4GkdiN7XgV8D67\"auth = tweepy.OAuthHandler(consumer_key, consumer_secret)auth.set_access_token(access_token, access_token_secret)api = tweepy.API(auth)# Open/Create a file to append datacsvFile = open('tweetsData.csv', 'a')#Use csv WritercsvWriter = csv.writer(csvFile)for tweet in tweepy.Cursor(api.search, q=\"key word\", since=\"2015-12-02\", until=\"2015-12-03\", #startSince = '2015-11-25 00:00:00', #endUntil = '2015-11-25 23:59:59', lang=\"en\").items(): #print tweet.created_at, tweet.text, tweet.place, tweet.coordinates csvWriter.writerow([tweet.created_at, tweet.text.encode('utf-8'),tweet.place,tweet.coordinates]) “key word”即为你需要的关键词，since起始日期，until结束日期，但是不能精确到HH:MM，及使用2015-11-25 00:00:00不行。结果以csv格式存储在tweetsData.csv中。其中注意的是不能频繁请求，否则出现twitter 629 错误,当然还有其它常见错误。获取更早以前的数据可以利用工具TOPSY和tweet。 2.Twitter数据分析（1）数据分析工具获得Twitter数据后，我们会将其进行简单分析，其中比较常规的是进行Sentiment Analysis, 可以利用工具sentiment140,但是数据量较小。还可以利用工具sentiment viz和Streamcrab工具,效果看起来不错。可以利用AlchemyAPI进行分析。我们还可以根据geolocation1,2,3属性做的更好。 sentiment140对twitter数据进行情感分析，后来发现其也提供相应的API，sentiment140 API使用较为简单。 数据 1&#123;'data': [&#123;'text': 'I love Titanic.'&#125;]&#125; 运行 123curl -d \"&#123;'data': [&#123;'text': 'I love Titanic.'&#125;]&#125;\" http://www.sentiment140.com/api/bulkClassifyJsoncurl --data-binary @test.txt \"http://www.sentiment140.com/api/bulkClassify?query=obama\"curl --data-binary @test.csv \"http://www.sentiment140.com/api/bulkClassify?query=obama\" 显示结果 1&#123;\"data\":[&#123;\"text\":\"I love Titanic.\",\"polarity\":4&#125;]&#125; 其中显示结果针对第一条运行命令，0: negative， 2: neutral，4: positive （2）Naive Bayes Classifier该博客中提供了很多twitter sentiment analysis算法，本博客讲述其中的一种方法Naive Bayes Classifier。下面是具体代码，包括数据得预处理过程，和特征提取过程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import reimport nltkimport csv#start process_tweetdef processTweet(tweet): # process the tweets #Convert to lower case tweet = tweet.lower() #Convert www.* or https?://* to URL tweet = re.sub('((www\\.[^\\s]+)|(https?://[^\\s]+))','URL',tweet) #Convert @username to AT_USER tweet = re.sub('@[^\\s]+','AT_USER',tweet) #Remove additional white spaces tweet = re.sub('[\\s]+', ' ', tweet) #Replace #word with word tweet = re.sub(r'#([^\\s]+)', r'\\1', tweet) #trim tweet = tweet.strip('\\'\"') return tweet#endstopWords = []#start replaceTwoOrMoredef replaceTwoOrMore(s): #look for 2 or more repetitions of character and replace with the character itself pattern = re.compile(r\"(.)\\1&#123;1,&#125;\", re.DOTALL) return pattern.sub(r\"\\1\\1\", s)#end#start getStopWordListdef getStopWordList(stopWordListFileName): #read the stopwords file and build a list stopWords = [] stopWords.append('AT_USER') stopWords.append('URL') fp = open(stopWordListFileName, 'r') line = fp.readline() while line: word = line.strip() stopWords.append(word) line = fp.readline() fp.close() return stopWords#end#start getfeatureVectordef getFeatureVector(tweet): featureVector = [] #split tweet into words words = tweet.split() for w in words: #replace two or more with two occurrences w = replaceTwoOrMore(w) #strip punctuation w = w.strip('\\'\"?,.') #check if the word stats with an alphabet val = re.search(r\"^[a-zA-Z][a-zA-Z0-9]*$\", w) #ignore if it is a stop word if(w in stopWords or val is None): continue else: featureVector.append(w.lower()) return featureVector#end#start extract_featuresdef extract_features(tweet): tweet_words = set(tweet) features = &#123;&#125; for word in featureList: features['contains(%s)' % word] = (word in tweet_words) return features#end#Read the tweets one by one and process itinpTweets = csv.reader(open('traindata.csv', 'rb'), delimiter=',', quotechar='|')#stopWords = getStopWordList('data/feature_list/stopwords.txt')featureList = []# Get tweet wordstweets = []for row in inpTweets: sentiment = row[0] tweet = row[1] processedTweet = processTweet(tweet) featureVector = getFeatureVector(processedTweet) featureList.extend(featureVector) tweets.append((featureVector, sentiment));#end loop# Remove featureList duplicatesfeatureList = list(set(featureList))# Extract feature vector for all tweets in one shotetraining_set = nltk.classify.util.apply_features(extract_features, tweets) # Train the classifierNBClassifier = nltk.NaiveBayesClassifier.train(training_set)# Test the classifierinputdata=csv.reader(open('data12-2.csv','rb'))positive=0negative=0testTweet=[]for row in inputdata: testTweet=row[1]#testTweet = 'I do not think you are good boy.' processedTestTweet = processTweet(testTweet) result=NBClassifier.classify(extract_features(getFeatureVector(processedTestTweet))) #print result#print NBClassifier.classify(extract_features(getFeatureVector(processedTestTweet))) if result == \"positive\": positive=positive+1 else: negative=negative+1print(positive)print(negative) 代码中要进行分类的twiiter数据集为data12-2.csv，其中testTweet=row[1]是获取twitter的文本信息。训练集traindata.csv来自Movie Review Data中的sentence polarity dataset v1.0，然后将数据经过变换成如下的形式。123456|positive|,|@PrincessSuperC Hey Cici sweetheart! Just wanted to let u know I luv u! OH! and will the mixtape drop soon? FANTASY RIDE MAY 5TH!!!!||positive|,|@Msdebramaye I heard about that contest! Congrats girl!!||positive|,|UNC!!! NCAA Champs!! Franklin St.: I WAS THERE!! WILD AND CRAZY!!!!!! Nothing like it...EVER http://tinyurl.com/49955t3||negative|,|Disappointing day. Attended a car boot sale to raise some funds for the sanctuary, made a total of 88p after the entry fee - sigh||negative|,|no more taking Irish car bombs with strange Australian women who can drink like rockstars...my head hurts.||negative|,|Just had some bloodwork done. My arm hurts|","categories":[{"name":"学习","slug":"学习","permalink":"http://flame160.git.io/categories/学习/"}],"tags":[{"name":"sentiment analysis","slug":"sentiment-analysis","permalink":"http://flame160.git.io/tags/sentiment-analysis/"},{"name":"python","slug":"python","permalink":"http://flame160.git.io/tags/python/"}]},{"title":"数据挖掘-特征提取","slug":"数据挖掘-特征提取","date":"2015-11-15T11:14:11.000Z","updated":"2018-03-29T10:32:30.513Z","comments":true,"path":"2015/11/15/数据挖掘-特征提取/","link":"","permalink":"http://flame160.git.io/2015/11/15/数据挖掘-特征提取/","excerpt":"数据挖掘如今在各个领域起到的作用越来越大，学习数据挖掘首先要了解数据挖掘十大算法，网易公开课中提供了一个machine learning学习入门较好的课程Andrew Ng 的 Machine Learning 课程。入门后可以学习几本不错的书，如Bishop 的 Pattern Recognition and Machine Learning，elements of statistical learning和Machine Learning A Probabilistic Perspective也是非常好的参考书。此外也可以看看一些相关会议的论文,包括 SIGMOD, KDD, ICDM, ICML, NIPS, IJCAI, AAAI 等等。本博客介绍数据挖掘中用于特征提取方法：1.主成分分析（PCA）;2.独立成分分析（ICA）;3.Gabor变换;4.匹配追踪。","text":"数据挖掘如今在各个领域起到的作用越来越大，学习数据挖掘首先要了解数据挖掘十大算法，网易公开课中提供了一个machine learning学习入门较好的课程Andrew Ng 的 Machine Learning 课程。入门后可以学习几本不错的书，如Bishop 的 Pattern Recognition and Machine Learning，elements of statistical learning和Machine Learning A Probabilistic Perspective也是非常好的参考书。此外也可以看看一些相关会议的论文,包括 SIGMOD, KDD, ICDM, ICML, NIPS, IJCAI, AAAI 等等。本博客介绍数据挖掘中用于特征提取方法：1.主成分分析（PCA）;2.独立成分分析（ICA）;3.Gabor变换;4.匹配追踪。 1.主成分分析PCA（1）PCA简介 主成分分析PCA(Principle Component Analysis):将多个变量通过线性变换以选出较少个数重要变量的一种多元统计分析方法，又称主分量分析。 主成分分析PCA原理:在用统计分析方法研究多变量的课题时，变量个数太多就会增加课题的复杂性。人们自然希望变量个数较少而得到的信息较多。在很多情形，变量之间是有一定的相关关系的，当两个变量之间有一定相关关系时，可以解释为这两个变量反映此课题的信息有一定的重叠。主成分分析是对于原先提出的所有变量，将重复的变量（关系紧密的变量）删去多余，建立尽可能少的新变量，使得这些新变量是两两不相关的，而且这些新变量在反映课题的信息方面尽可能保持原有的信息。设法将原来变量重新组合成一组新的互相无关的几个综合变量，同时根据实际需要从中可以取出几个较少的综合变量尽可能多地反映原来变量的信息的统计方法叫做主成分分析或称主分量分析，也是数学上用来降维的一种方法。 主成分分析PCA思想:将n维特征映射到k维上(k&lt;n)这k维是全新的正交特征。这k维特征称为主元，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征 （2）PCA分析 PCA的优点 可消除评价指标之间的相关影响:因为主成分分析在对原指标变量进行变换后形成了彼此相互独立的主成分，而且实践证明指标之间相关程度越高，主成分分析效果越好。 可减少指标选择的工作量:对于其它评价方法，由于难以消除评价指标间的相关影响，所以选择指标时要花费不少精力，而主成分分析由于可以消除这种相关影响，所以在指标选择上相对容易些。 当评级指标较多时还可以在保留绝大部分信息的情况下用少数几个综合指标代替原指标进行分析。 在综合评价函数中，各主成分的权数为其贡献率，它反映了该主成分包含原始数据的信息量占全部信息量的比重，这样确定权数是客观的、合理的，它克服了某些评价方法中认为确定权数的缺陷。 这种方法的计算比较规范，便于在计算机上实现，还可以利用专门的软件。 PCA缺点 在主成分分析中，我们首先应保证所提取的前几个主成分的累计贡献率达到一个较高的水平（即变量降维后的信息量须保持在一个较高水平上），其次对这些被提取的主成分必须都能够给出符合实际背景和意义的解释(否则主成分将空有信息量而无实际含义)。 主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义那么清楚、确切，这是变量降维过程中不得不付出的代价。因此，提取的主成分个数m通常应明显小于原始变量个数p(除非p本身较小)，否则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。 PCA适用范围 适用数据:多变量存在一定相关性,只对符合高斯分布的样本点比较有效。 适用范围:应用于去噪，降维：例如数据表示，模式识别、图像信息压缩、城市道路交通，水质环境评价….. （3）PCA计算PCA的计算过程涉及到矩阵相关的很多操作，具体计算过程我参考的是JerryLead 博客园,用一个实例详细讲解其具体计算过程，非常清楚，也就是降维的过程以及其数学上的理论基础。其中从n维降到k维的k值确定，则是根据特征向量的值需要占到特征向量值总和的百分比确定的。除了这篇博客以外，还有一篇文章A tutorial on Principal Components Analysis讲解的非常详细。 2.独立成分分析ICA（1）ICA简介 独立成分分析ICA(Independent Component Analysis)： ICA是一种用来从多变量（多维）统计数据里找到隐含的因素或成分的方法，被认为是主成分分析（Principal Component Analysis, PCA）和因子分析（Factor Analysis）的一种扩展。对于盲源分离问题，ICA是指在只知道混合信号，而不知道源信号、噪声以及混合机制的情况下，分离或近似地分离出源信号的一种分析过程。 独立成分分析ICA在维基百科中的解释是：一种利用统计原理进行计算的方法它是一个线性变换。这个变换把数据或信号分离成统计独立的非高斯的信号源的线性组合。独立成分分析是盲信号分离（Blind source separation）的一种特例。 典型实例:“鸡尾酒会”的问题,假设在party中有n个人，他们可以同时说话，我们也在房间中一些角落里共放置了n个声音接收器（Microphone）用来记录声音。宴会过后，我们从n个麦克风中得到了一组数据{$x^{(i)}(x_1^i,x_2^i,…,x_n^i);i=1,2,…,m$}，i表示采样的时间顺序，也就是说共得到了m组采样，每一组采样都是n维的。我们的目标是单单从这m组采样数据中分辨出每个人说话的信号。 （2）ICA分析 ICA约束 独立成分被假定是统计独立的（技术角度上理解：联合概率密度等于各边缘概率密度的乘积） 独立成分具有非高斯的分布 假定混合矩阵是方阵（就是独立成分的个数与观测到的混合量个数相同） ICA优点消除指标的影响和指标选取的工作量 ICA缺点独立成分分析并不能完全恢复信号源的具体数值，也不能解出信号源的正负符号、信号的级数或者信号的数值范围。 ICA适用范围 适用数据:非高斯分布的样本点 适用范围：应用于去噪、降维、信号分离：例如码分多址通信、雷达信号分选、心电图（胎儿）、脑电图、图像压缩、图像融合….. （3）ICA计算ICA的计算过程涉及到许多数学知识，具体计算过程我参考的是JerryLead 博客园,虽然讲解的很详细，以及有些公式还有其具体推到过程，但是对数学要求很高（由于很多数学知识忘了，公式中有些计算不是很理解）。 （4）PCA和ICA对比 PCA(principal components analysis)就是主成分分析，是数据分析中常用到的一种方法。它是找出数据最主要的方向，并将数据向该方向投影。ICA(Independent components analysis)就是独立成分分析。 PCA与ICA的区别主要在于假设条件不同。PCA假设数据是呈高斯或者说指数分布的，而ICA则假设数据是相互独立的。所以在实际处理中，ICA在小样本集时效果较好，而对于大样本集，PCA也能达到很好的效果。因为实际采样中，当采样样本较大时，其一般是呈高斯分布的。PCA的几个主要假设包括：1.处理数据集是线性的，对于非线性问题，有核化PCA可以进行处理，该方法主要是利用非线性权值对线性PCA进行扩展。2.PCA是使用中值和方差来进行概率分布的描述，而这种方法仅适用于样本呈指数分布的情形，所以PCA假设数据时呈高斯分布的。3.PCA隐含着假设：数据具有较高的信噪比，所以具有最大方差的方向被作为主元，而方差最小的方向被作为噪声，这是由低通滤波器的特性决定的。4.主元正交：PCA假设主元之间是正交的，这样假设有利于采用线性代数的方法进行求解。 PCA和ICA性能的比较：由于PCA假设的是样本呈高斯分布，所以其在大样本情况下效果较好，而ICA假设样本彼此独立，其效果受样本数量影响不大。对于实验效果，PCA的约束条件是要求各分量不相关，而ICA则是要求严格独立，显然ICA约束比PCA要强很多，所以ICA的特征提取能力比PCA要强很多。 3.Gabor变换（1）Gabor变换简介 伽柏（Gabor）变换：Gabor变换是一种加窗短时傅立叶(Fourier)变换（Window Fourier transform or Short Time Fourier Transform）,Gabor函数可以在频域不同尺度、不同方向上提取相关的特征。Gabor变换是短时Fourier变换中当窗函数取为高斯函数时的一种特殊情况。 Gabor变换的基本思想：把信号划分成许多小的时间间隔，用Fourier变换分析每一个时间间隔，以便确定信号在该时间间隔存在的频率。其处理方法是对f(t)加一个滑动窗，再作Fourier变换。 Gabor变换的本质:实际上还是对二维图像求卷积。因此二维卷积运算的效率就直接决定了Gabor变换的效率。 Fourier变换:是整体上将信号分解为不同的频率分量（任何信号都可分解为复正弦信号之和），对确定性信号及平稳信号使用。其缺点为缺乏时间的局部性信息，并且对时变信号、非平稳信号的分析存在严重不足，(1)无法告知某些频率成分发生在哪些时间内；(2)无法告知某个时刻信号频谱的分布情况。 Fourier变换将时域信号发f(t)转换到频域信号： Fourier逆变换将频域信号转换到时域信号： 其中信号f(t)在任一有限区间满足狄利克雷条件:(1)在一周期内，如果有间断点存在，则间断点的数目应是有限个;(2)在一周期内，极大值和极小值的数目应是有限个;(3)在一周期内，信号是绝对可积的。并且f(t)在$(-\\infty,+\\infty)$上绝对可即。 对于Fourier变换网上有很多讲解，如果最开始对Fourier变换没有一点了解，可以看一下这篇博客,让你更清楚的认识Fourier变换。 （2）Gabor变换分析 Gabor变换优点在提取目标的局部空间和频率域信息方面具有良好的特性。 Gabor变换的缺点Gabor变换在一定程度上解决了局部分析的问题，但对于突变信号和非平稳信号仍难以得到满意的结果，即Gabor变换仍存在着较严重的缺陷。 Gabor变换的时频窗口大小、形状不变，只有位置变化，而实际应用中常常希望时频窗口的大小、形状要随频率的变化而变化，因为信号的频率与周期成反比，对高频部分希望能给出相对较窄的时间窗口，以提高分辨率，在低频部分则希望能给出相对较宽的时间窗口，以保证信息的完整性，总之是希望能给出能够调节的时频窗； Gabor变换基函数不能成为正交系，因此为了不丢失信息，在信号分析或数值计算时必须采用非正交的冗余基，这就增加了不必要的计算量和存储量。 无论研究低频成分还是研究高频成分，Gabor变换所采用的时间-频率窗口的宽度和高度都不变，这对研究较高频率或者较低频率都不利。 Gabor变化适用范围:非平稳信号。例如可应用于(1)暂态信号检测(2)图象分析与压缩 很多博客里面都讲解到了二维卷积运算和Gabor定义,以及Gabor函数,《非平稳信号特征提取方法及其应用——范虹 著》中的Gabor展开。 4.匹配追踪（1）匹配追踪简介 匹配追踪:由Mallat等和Qian等基于投影追踪算法提出的逐步递推算法，是一种自适应分解算法。 匹配追踪分解信号的关键:在于找出一系列时频原子，这些时频原子通过逐次分解信号得到。在每一步分解过程中，都寻求与残余信号最为相似的时频原子。 （2）匹配追踪分析 匹配追踪优点匹配追踪算法在思想上摆脱了传统小波分析基于二分频带的约束，是小波框架理论的发展。对于那些单纯使用Fourier基或小波基难以有效表示的高温非平稳信号，应用该算法都可以很好的表示。 匹配追踪缺点 算法实现计算量太大。2.不以得到全局最优解 时频原子的选取与构造比较困难针对这些缺点，人们尝试采用遗传算法实现匹配追踪的分解，以降低匹配追踪算法的计算量。 （3）信号分析方法 平稳信号处理方法 时域分析方法:概率分析法、时域同步平均法、相关分析法，提取信号的幅值、周期、频率、相位以及均值、方差、方根、方根幅值、均方根值、峰值、偏斜度、峭度、波形指标、峰值指标、脉冲指标、裕度指标。 频域分析方法:频谱分析、倒频谱分析、包络分析。 非平稳信号时频分析方法Gabor变换，短时Fourier变换、小波分析、双线性时频分析法、自适应信号分解(匹配追踪)、Hilbert-Huang时频分析法","categories":[{"name":"科研","slug":"科研","permalink":"http://flame160.git.io/categories/科研/"}],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://flame160.git.io/tags/数据挖掘/"},{"name":"特征提取","slug":"特征提取","permalink":"http://flame160.git.io/tags/特征提取/"}]},{"title":"MySQL数据库操作","slug":"MySQL数据库操作","date":"2015-11-10T11:35:42.000Z","updated":"2018-03-29T10:29:20.929Z","comments":true,"path":"2015/11/10/MySQL数据库操作/","link":"","permalink":"http://flame160.git.io/2015/11/10/MySQL数据库操作/","excerpt":"数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。在学习网站的过程中，遇到很多对数据库的相关操作，经过学习之后，在这里进行整理，列出对数据库的基本操作，本博客只是对应用较为常见的操作进行整理。MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。","text":"数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。在学习网站的过程中，遇到很多对数据库的相关操作，经过学习之后，在这里进行整理，列出对数据库的基本操作，本博客只是对应用较为常见的操作进行整理。MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。 mysql服务操作 启动或关闭mysql服务 12net start mysql//启动服务net stop mysql //关闭服务 增加新用户 1234grant 权限 on 数据库.* to 用户名@登陆主机 identified by \"密码\"//基本格式grant select,insert,update,delete on *.* to user1@localhost identified by \"password1\";//具体例子//用户名为user1，密码为password1，让其在本机上登陆，并对所有的数据库有查询、插入、修改、删除的权限。//首先以root用户连接mysql，然后键入该命令 进入数据库 123mysql -u用户名 -p//Enter键后在输入密码mysql -u用户名 -p密码//mysql -uroot -proot(用户名:root,密码:root)mysql -h主机地址 -u用户名 -p密码//指定连接主机 退出mysql操作 1quit/exit //更改密码 mysql常用命令 命令 说明 SELECT VERSION(); 显示当前服务器版本 SELECT NOW(); 显示当前日期时间 SELECT USER(); 显示当前用户 数据库操作 命令 说明 show databases; 列出数据库 use database_name; 使用database_name数据库 create database think character set utf8 ; 创建数据库think(数据库名)，设置编码为utf8 drop database think; 删除数据库think(数据库名) grant all on wish.* to “hdw” @”localhost” identified by “hdw”; 只允许hdw用户操作数据库wish，密码是hdw C://mysqldump -uroot -p houdunwang &gt; d:/houdunwang.sql 将数据库houdunwang中的数据导出d:/houdunwang.sql(未通过mysql进入) C://mysql -uroot -p houdunwang &lt; d:/houdunwang.sql 将数据d:/houdunwang.sql导入数据库houdunwang(未通过mysql进入) mysql&gt;source d:/houdunwang.sql; 将数据d:/houdunwang.sql导入数据库houdunwang(已通过mysql进入) 对数据库中表的操作 查看表属性 12show tables //查看表名desc hd_wish //查看表hd_wish结构 创建表 1234create table hd_wish(id int unsigned not null primary key auto_increment, username varchar(20) not null default '',contentvarchar(255) not null default '',time int(10) not null default 0) engine myisam charset utf8;//创建表hd_wish（primary key 定义这个字段为主键，auto_increment 定义这个字段为自动增长，引擎为myisam，字符集为utf8）create table new_tab_name like old_tab_name; //用一个已存在的表来建新表，但不包含旧表的数据 查看表中的数据 1234567891011select *from hd_wish; //查看表hd_wish中的所有数据select *from hd_wish where id=1; //查看表hd_wish中的id=1的数据select count(*) from hd_wish; //统计表hd_wish中有多少条记录select *from stu where sname like \"李%\"; //模糊匹配select if(sex \"男生\",\"女生\") as stusex,sname from stu; //as取别名（stusex）select concat(\"姓名:\",sname,\"性别:\",sex,\"QQ\",qq) as stuinfo from stu; //字符串与字段进行连接select *from stu order by id desc limit 0,1; //从第零个开始取1个select *from stu order by id desc limit 4; //取4条数据select distinct year(birday) as \"出生年份\" from stu; //distinct去掉重复的部分,year(birday)只得到年份select user.value from user where user.uid in (select mete.uid from mete where mete.cid=1);//从表user中查找数据user.value,其满足user.uid满足的条件为：mete表中mete。cid为1的mete.uid。 插入 12insert into hd_user set username='admin',password=md5('admin'),logintime=unix_timestamp(now()); //向表hd_user中插入数据（非标准版）insert into hd_user(username,password,logintime) values('admin',md5('admin'),unix_timestamp(now())); //向表hd_user中插入数据（标准版） 删除 1234drop table hd_wish; //删除表hd_wishdelete from hd_wish; //将表hd_wish中的记录清空delect from hd_wish where username=\"admin\"; //可用 WHERE 子句来选择所要删除的记录delete table table_name column colmn_name; //删除表中的一个字段 修改 12345alter table tab_name add PRIMARY KEY (col_name); //更改表得的定义把col_num设为主键alter table tab_name drop PRIMARY KEY (col_name); //把主键的定义删除update stu set birday=\"1990/2/23\" where id=1; //修改表stu中id=1的数据(将birday修改为\"1990/2/23\")alter table tab_name rename to new_tab_name; //修改表名alter table tab_name change old_col new_col varchar(20); //修改字段名--必须为当前字段指定数据类型等属性，否则不能修改 增加 12alter table stu add birday date; //增加表stu字段birdayalter table stu add name varchar(20) not null default ''; //增加表stu字段name 其它 取消 12\\c //取消所有命令 Esc //取消本行命令 外键 1234567891011CREATE TABLE provinces ( id SMALLINT(5) UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT, pname VARCHAR(20) NOT NULL)ENGINE MYISAM DEFAULT CHARSET utf8;CREATE TABLE users ( id SMALLINT(5) UNDSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, pid SMALLINT(5) UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces (id))ENGINE MYISAM DEFAULT CHARSET utf8;; 参考：MySQL数据库基本操作命令","categories":[{"name":"学习","slug":"学习","permalink":"http://flame160.git.io/categories/学习/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://flame160.git.io/tags/数据库/"}]},{"title":"STL标准模板库","slug":"STL标准模板库","date":"2015-10-30T05:19:54.000Z","updated":"2018-03-29T10:05:01.813Z","comments":true,"path":"2015/10/30/STL标准模板库/","link":"","permalink":"http://flame160.git.io/2015/10/30/STL标准模板库/","excerpt":"STL是标准模板库，是一些容器的集合。vector是STL中最常见的容器，它是一种顺序容器，支持随机访问。vector是一块连续分配的内存，从数据安排的角度来讲，和数组极其相似，不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。 C++队列queue是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。 C++ STL中标准关联容器set, multiset, map, multimap内部采用的是一种非常高效的平衡检索二叉树：红黑树。","text":"STL是标准模板库，是一些容器的集合。vector是STL中最常见的容器，它是一种顺序容器，支持随机访问。vector是一块连续分配的内存，从数据安排的角度来讲，和数组极其相似，不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。 C++队列queue是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。 C++ STL中标准关联容器set, multiset, map, multimap内部采用的是一种非常高效的平衡检索二叉树：红黑树。 1.vector基本用法vector: 内部实现是数组，一段连续的内存。vector是C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。vector的大小：size，vector的容量：capacity。size表示vector中已有元素的个数，capacity表示vector最多可存储的元素的个数。为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，即capacity&gt;=size。当等于时，容器此时已满，若再要加入新的元素时，就要重新进行内存分配，整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。当vector的容量不足以插入count个元素，即capacity &lt;size + count需要进行二次分配，扩大vector的容量。在VS下，vector容量会扩大50%，即 capacity = capacity+ capacity / 2; 若仍不足，则 capacity = size + count。 头文件 #include &lt;vector &gt;, 命名域std(using std:vector), 建议使用全局的命名域(using namespace std); 创建vector对象, vector &lt;int &gt; vec; 尾部插入元素a, vec.push_back(a); 使用下标访问元素, cout&lt;&lt;vec[0]&lt;&lt;endl; 使用迭代器访问元素 123vector&lt;int&gt;::iterator it;for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl; 插入元素, vec.insert(vec.begin()+i,a); 在第i+1个元素前面插入a; 删除元素, vec.erase(vec.begin()+2); 删除第3个元素;vec.erase(vec.begin()+i,vec.begin()+j); 删除区间[i,j-1],区间从0开始iterator erase( iterator _Where);iterator erase( iterator _First, iterator _Last);如果是删除指定位置的元素时：返回值是一个迭代器，指向删除元素下一个元素;如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素; 向量大小, vec.size(); 清空, vec.clear(); 12345678910111213141516171819202122232425262728293031#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;#define a 101int main()&#123; int i; vector&lt;int&gt; vec;//创建vector对象 for(i=0;i&lt;10;i++) &#123; vec.push_back(i);//尾部插入元素 &#125; cout&lt;&lt;vec.size()&lt;&lt;endl;;//向量大小 //vec.insert(vec.begin()+i,a);//在第i+1个元素面前插入元素a vec.insert(vec.begin()+3,a);//在第4个元素前面插入元素a vec.erase(vec.begin()+2);//删除第3个元素 //vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始 vec.erase(vec.begin()+2,vec.begin()+5); for(i=0;i&lt;vec.size();i++) &#123; cout&lt;&lt;vec[i]&lt;&lt;\",\"; &#125; cout&lt;&lt;endl; //使用迭代器访问元素 vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;\",\"; vec.clear();//清空 system(\"pause\");&#125; vector成员函数vector还提供了很多接口，在下面的表中列出vector的成员函数和操作。 函数 表述 c.assign(beg,end),c.assign(n,elem) 将[beg; end)区间中的数据赋值给c,将n个elem的拷贝赋值给c。 c.at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range。 c.back() 传回最后一个数据，不检查这个数据是否存在。 c.begin() 传回迭代器重的可一个数据。 c.capacity() 返回容器中数据个数。 c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.end() 指向迭代器中的最后一个数据地址。 c.erase(pos),c.erase(beg,end) 删除pos位置的数据，传回下一个数据的位置;删除[beg,end)区间的数据，传回下一个数据的位置。 c.front() 传回第一个数据。 get_allocator 使用构造函数返回一个拷贝。 c.insert(pos,elem) 在pos位置插入一个elem拷贝，传回新数据位置。 c.insert(pos,n,elem) 在pos位置插入n个elem数据。无返回值。 c.insert(pos,beg,end) 在pos位置插入在[beg,end)区间的数据。无返回值。 c.max_size() 返回容器中最大数据的数量。 c.pop_back() 删除最后一个数据。 c.push_back(elem) 在尾部加入一个数据。 c.rbegin() 传回一个逆向队列的第一个数据。 c.rend() 传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num) 重新指定队列的长度。 c.reserve() 保留适当的容量。 c.size() 返回容器中实际数据的个数。 c1.swap(c2),swap(c1,c2) 将c1和c2元素互换;同上操作 vector c 创建一个空的vector。 vector c1(c2) 复制一个vector。 vector c(n) 创建一个vector，含有n个数据，数据均已缺省构造产生。 vector c(n, elem) 创建一个含有n个elem拷贝的vector。 vector c(beg,end) 创建一个以[beg;end)区间的vector。 c.~ vector () 销毁所有数据，释放内存。 2.queue基本用法queue用deque实现,deque内部实现是内存块的链表。deque双向队列是一种双向开口的连续线性空间，可以高效的在头尾两端插入和删除元素，deque在接口上和vector非常相似。 头文件 #include &lt;queue &gt;; 创建queue对象, queue &lt;int &gt; q1;queue &lt;double &gt; q2; 入队列-将x元素接到队列的末端, q.push(x); 出队列, q.pop()弹出队列的第一个元素，并不返回元素的值; 访问队首元素, q.font(); 访问队尾元素, q.back(); 队列中的元素的个数, q.size(); 判断队列空, q.empty(),当队列空时,返回true。 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() &#123; queue&lt;int&gt; que; for(int i=0;i&lt;10;i++) que.push(i); if(!que.empty()) cout&lt;&lt;\"队列不为空!\"&lt;&lt;endl; int n=que.size(); cout&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;que.front()&lt;&lt;endl; cout&lt;&lt;que.back()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;endl; system(\"pause\"); return 0; &#125; priority_queue, 在&lt;queue &gt;头文件中,还定义了一个非常有用的模板类priority_queue(优先队列)。优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队列(默认为大者优先，也可以通过指定算子来指定自己的优先顺序)。 priority_queue模板类有三个模板参数，第一个是元素类型，第二个容器类型，第三个是比较算子。其中后两个都可以省略,默认容器为vector,默认算子为less,即小的往前排,大的往后排(出队列时序列尾的元素出队列)。1234priority_queue&lt;int&gt; q1;priority_queue&lt; pair&lt;int, int&gt; &gt; q2; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 定义小的先出队priority_queue 的基本操作与queue 相同。 3.stack基本用法C++ stack(堆栈)是一个容器的改编，它实现了先进后出的数据结构(FILO)。stack的具体应用实例有效的括号Valid Parentheses。 头文件: #include &lt;stack &gt;。 创建stack对象: stack &lt;int &gt;s。 判断栈空: empty(),当栈空时返回ture。 移除栈顶元素: pop(),该操作只是删除栈顶的元素，并不返回该元素。 在栈顶增加元素: push(),如s.push(x)。 返回栈中元素数目: size()。 返回栈顶元素: top()。 简单的例子： 12345678910111213141516#include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main(void) &#123; stack&lt;double&gt;s;//定义一个栈 for(int i=0;i&lt;10;i++) s.push(i); while(!s.empty()) &#123; printf(\"%lf\\n\",s.top()); s.pop(); &#125; cout&lt;&lt;\"栈内的元素的个数为：\"&lt;&lt;s.size()&lt;&lt;endl; return 0; &#125; 4.map基本用法map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字Key，每个关键字只能在map中出现一次，第二个可以称为该关键字的值Value）的数据处理能力，由于这个特性，它完成在我们处理一对一的数据的时候，在编程上提供快速的通道。map内部自建一颗红黑树（一种非严格的平衡二叉树），这棵树具有对数据的自动排序功能。map的具体应用实例单词模式Word Pattern。 头文件: #include &lt; map &gt; map最基本的构造函数自动建立Key － value的对应，key 和 value可以是任意你需要的类型。 123map&lt;string , int &gt;mapstring; map&lt;int ,string &gt;mapint;map&lt;sring, char&gt;mapstring; map&lt; char ,string&gt;mapchar;map&lt;char ,int&gt;mapchar; map&lt;int ,char &gt;mapint； map中插入元素 第一种：用insert函数插入pair数据pair是一种模版类型。每个pair可以存储两个值。这两种值无限制。也可以将自己写的struct的对象放进去。 1234567891011121314151617#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; //pair&lt;int,string&gt;p;p=make_pair(v1,v2);make_pair()返回类型为对应的pair类型 mapStudent.insert(pair&lt;int, string&gt;(1, \"student_one\")); mapStudent.insert(pair&lt;int, string&gt;(2, \"student_two\")); mapStudent.insert(pair&lt;int, string&gt;(3, \"student_three\")); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout&lt;&lt;iter-&gt;first&lt;&lt;\" \"&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; &#125; 第二种:用insert函数插入value_type数据 12345678910111213141516#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type (1, \"student_one\")); mapStudent.insert(map&lt;int, string&gt;::value_type (2, \"student_two\")); mapStudent.insert(map&lt;int, string&gt;::value_type (3, \"student_three\")); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout&lt;&lt;iter-&gt;first&lt;&lt;\" \"&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; &#125; 第三种:用数组的方式插入数据 12345678910111213141516#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = \"student_one\"; mapStudent[2] = \"student_two\"; mapStudent[3] = \"student_three\"; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout&lt;&lt;iter-&gt;first&lt;&lt;\" \"&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; &#125; map的大小在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数。 1int nSize = mapStudent.size(); map查找元素 第一种:用count函数来判定关键字是否出现其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了。 1234567891011121314151617181920#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;string,int&gt; test; test.insert(make_pair(\"test1\",1)); test.insert(make_pair(\"test2\",2)); //如果map中存在所要查找的主键，就返回一 int count = test.count(\"test2\"); cout&lt;&lt;\"the value of count:\"&lt;&lt;count&lt;&lt;endl; map&lt;string,int&gt;::iterator it = test.find(\"test2\"); //如果map中没有索要查找的主键，就返回map.end(); if(it != test.end()) cout&lt;&lt;\"has find the string\"&lt;&lt;endl; system(\"pause\");&#125; 第二种:用find函数来定位数据出现位置 它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。 123456789101112131415161718192021#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, \"student_one\")); mapStudent.insert(pair&lt;int, string&gt;(2, \"student_two\")); mapStudent.insert(pair&lt;int, string&gt;(3, \"student_three\")); map&lt;int, string&gt;::iterator iter; iter = mapStudent.find(1); if(iter != mapStudent.end()) &#123; cout&lt;&lt;\"Find, the value is \"&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"Do not Find\"&lt;&lt;endl; &#125; &#125; 第三种:Lower_bound函数和Upper_bound函数 Lower_bound函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器)，Upper_bound函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器)。lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素。upper_bound(k)返回一个迭代器，指向键大于k的第一个元素例如：map中已经插入了1，2，3，4的话，如果lower_bound(2)的话，返回的2，而upper-bound（2）的话，返回的就是3。Equal_range函数返回一个pair，pair里面第一个变量是Lower_bound返回的迭代器，pair里面第二个迭代器是Upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = \"student_one\"; mapStudent[3] = \"student_three\"; mapStudent[5] = \"student_five\"; map&lt;int, string&gt;::iterator iter; iter = mapStudent.lower_bound(2); &#123; //返回的是下界3的迭代器 cout&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; iter = mapStudent.lower_bound(3); &#123; //返回的是下界3的迭代器 cout&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; iter = mapStudent.upper_bound(2); &#123; //返回的是上界3的迭代器 cout&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; iter = mapStudent.upper_bound(3); &#123; //返回的是上界5的迭代器 cout&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; pair&lt;map&lt;int, string&gt;::iterator, map&lt;int, string&gt;::iterator&gt; mapPair; mapPair = mapStudent.equal_range(2); if(mapPair.first == mapPair.second) &#123; cout&lt;&lt;\"Do not Find\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"Find\"&lt;&lt;endl; &#125; mapPair = mapStudent.equal_range(3); if(mapPair.first == mapPair.second) &#123; cout&lt;&lt;\"Do not Find\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"Find\"&lt;&lt;endl; &#125; &#125; map数据的清空与判断 清空map中的数据可以用clear()函数，判定map中是否有数据可以用empty()函数，它返回true则说明是空map。 map数据的删除 这里要用到erase函数，它有三个重载了的函数。 1234iterator erase(iterator it); //通过一个条目对象删除 iterator erase(iterator first, iterator last); //删除一个范围 size_type erase(const Key&amp; key); //通过关键字删除 clear()就相当于 enumMap.erase(enumMap.begin(), enumMap.end()); 12345678910111213141516171819202122#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, \"student_one\")); mapStudent.insert(pair&lt;int, string&gt;(2, \"student_two\")); mapStudent.insert(pair&lt;int, string&gt;(3, \"student_three\")); //如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好 //如果要删除1,用迭代器删除 map&lt;int, string&gt;::iterator iter; iter = mapStudent.find(1); mapStudent.erase(iter); //如果要删除1，用关键字删除 int n = mapStudent.erase(1);//如果删除了会返回1，否则返回0 //用迭代器，成片的删除 //一下代码把整个map清空 mapStudent.earse(mapStudent.begin(), mapStudent.end()); //成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合 &#125; map的基本操作函数 函数 表述 begin() 返回指向map头部的迭代器 clear(） 删除所有元素 count() 返回指定元素出现的次数 empty() 如果map为空则返回true end() 返回指向map末尾的迭代器 equal_range() 返回特殊条目的迭代器对 erase() 删除一个元素 find() 查找一个元素 get_allocator() 返回map的配置器 insert() 插入元素 key_comp() 返回比较元素key的函数 lower_bound() 返回键值&gt;=给定元素的第一个位置 max_size() 返回可以容纳的最大元素个数 rbegin() 返回一个指向map尾部的逆向迭代器 rend() 返回一个指向map头部的逆向迭代器 size() 返回map中元素的个数 swap() 交换两个map upper_bound() 返回键值&gt;给定元素的第一个位置 value_comp() 返回比较元素value的函数 5.list基本用法list是一个线性双向链表结构,它的数据由若干个节点构成，每个节点都包括一个信息块(即实际存储的数据)、一个前驱指针和一个后驱指针。它无需分配指定的内存大小且可以任意伸缩。list将元素按顺序储存在链表中. 与向量(vector)相比,它允许快速的插入和删除,但是随机访问却比较慢。 头文件, #include &lt;list &gt; 构造析构 123456list&lt;Elem&gt; c //创建一个空的list list&lt;Elem&gt; c1(c2) //复制另一个同类型元素的list list&lt;Elem&gt;c(n) //创建n个元素的list，每个元素值由默认构造函数确定 list&lt;Elem&gt;c(n,elem) //创建n个元素的list，每个元素的值为elem list&lt;Elem&gt;c(begin,end) //由迭代器创建list,迭代区间为[begin,end) c.~list(); // 销毁所有元素,释放内存 插入元素 12345c.push_back(Elem) //list元素尾部增加一个元素c.push_front(Elem) //list元素首元素前添加一个元素c.insert(pos,Elem) //在pos位置插入一个Elem拷贝,返回新数据的位置 c.insert(pos,n,Elem) //在pos位置插入n个Elem数据,无返回值 c.insert(pos,begin,end)//在pos位置插入在[begin,end)区间的数据,无返回值 数据访问 123456789c.front() //返回第一个数据 c.back() //返回最后一个数据 c.begin() //返回指向第一个元素的迭代器(指针) c.end() //返回指向最后一个数据的下一个位置的迭代器(指针) c.rbegin() //返回逆向队列的第一个数据,也就是返回容器中倒数第一个元素的迭代器 c.rend() //返回指向逆向队列的最后一个数据的下一个位置的迭代器， //也就是返回容器中倒数最后一个元素之后的迭代器 删除元素 1234567891011121314151617181920c.pop_back() //删除容器尾元素，当且仅当容器不为空 c.pop_front() //删除容器首元素，当且仅当容器不为空 c.remove(Elem) //删除容器中所有元素值等于x的元素 /* remove_if()删除条件满足的元素(会遍历一次链表) */ void remove_if_test()&#123; ShowList(g_list1); g_list1.remove_if(myFun); ShowList(g_list1); &#125; c.clear() //删除容器中的所有元素 c.erase(pos) //删除pos位置的数据，返回下一个数据的位置 c.erase(begin,end) //删除[begin,end)区间的数据，返回下一个数据的位置 c.unique() //删除相邻重复元素 //示例 L1( 1, 1 ,4,3,5,1) L1.unique( ); // L1(1,4,3,5,1) 其它 函数 表述 c.empty() list是否为空 c.reverse() 反转链表 c.sort() 将链表排序，默认升序 c.sort(comp) 自定义回调函数实现自定义排序 c1.merge(c2) 合并2个有序的链表并使之有序,从新放到c1里,释放c2 c1.merge(c2,comp) 合并2个有序的链表并使之按照自定义规则排序之后从新放到c1中,释放c2 c1.swap(c2)或者swap(c1,c2) 将c1和c2交换 resize(n) 从新定义链表的长度,超出原始长度部分用0代替,小于原始部分删除 resize(n,num) 从新定义链表的长度,超出原始长度部分用num代替 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123; list&lt;int&gt; c1(3); //list&lt;int&gt; c1(3,2); list&lt;int&gt; c2; list&lt;int&gt;::iterator it; if(!c1.empty())//是否为空 &#123; cout&lt;&lt;\"c1 is not empty\"&lt;&lt;endl; cout&lt;&lt;c1.size()&lt;&lt;endl;//元素个数 for(it=c1.begin();it!=c1.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; //添加元素 c1.push_front(1); c1.push_back(2); c2.push_front(11); c2.push_back(12); c2.insert(c2.begin(),13); //删除元素 c1.pop_back();// 删除末尾的元素 c2.pop_front();//删除第一个元素 cout&lt;&lt;c1.front()&lt;&lt;\",\"&lt;&lt;c2.back()&lt;&lt;endl; //返回链表元素。 c1.reverse(); //反转链表 c1.merge(c2); //合并链表，合并后销毁c2 for(it=c1.begin();it!=c1.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(it=c2.begin();it!=c2.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; system(\"pause\"); return 0;&#125; 6.set基本用法set集合容器：实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。 set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。 头文件 #include &lt;set &gt;, 命名域std(using std:vector), 建议使用全局的命名域(using namespace std); 创建set对象, set &lt;int &gt; s; 常用方法 函数 表述 insert() 插入元素s.insert(1); begin() 返回set容器的第一个元素*s.begin() end() 返回set容器的最后一个元素*s.end() clear() 删除set容器中的所有的元素 empty() 判断set容器是否为空s.empty() size() 返回当前set容器中的元素个数s.size() max_size() 返回set容器可能包含的元素最大个数s.max_size() rbegin 返回的值和end()相同 rend() 返回的值和rbegin()相同 count() 用来查找set中某个某个键值出现的次数,只有0次和1次s.count(1) find() 返回给定值值得定位器，如果没找到则返回end() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;set&gt;#include&lt;functional&gt; using namespace std;int main()&#123; set&lt;int&gt; s;//默认为升序 set&lt;int, greater&lt;int&gt;&gt;s2;//由于greater&lt;&gt;是个函数，降序，所以要加这个头文件#include&lt;functional&gt; multiset&lt;int&gt; s3;//multiset允许插入重复值 s.insert(2); s.insert(100); s.insert(1); s.insert(1);//元素1已经存在，所以不会再次插入1 s2.insert(3); s2.insert(2); s3.insert(10); s3.insert(3); s3.insert(3);//元素3已经存在，但是会再次插入3 set&lt;int&gt;::iterator it; cout &lt;&lt; \"set 的 size 值为 ：\" &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; \"set 的 maxsize的值为 ：\" &lt;&lt; s.max_size() &lt;&lt; endl; cout &lt;&lt; \"set 中的第一个元素是 ：\" &lt;&lt; *s.begin() &lt;&lt; endl; for (it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (it = s3.begin(); it != s3.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; set&lt;int&gt;::iterator itor; itor = s.find(2); if (itor != s.end()) // itor point to s.end() if not found cout &lt;&lt; \"found\"&lt;&lt;endl; else cout &lt;&lt; \"not found\"&lt;&lt;endl; if (s.count(4) == 1) // return 1 if s contains 4, else 0 cout &lt;&lt; \"s contains 4\" &lt;&lt; endl; else cout &lt;&lt; \"s does not contains 4\" &lt;&lt; endl; system(\"pause\"); return 0;&#125; 参考： STL vector用法介绍 STL vector的内部实现原理及基本用法 STL中队列（queue）的使用方法 STL系列之一 deque双向队列 c++stack容器介绍 map的详细用法 C++ map的基本操作和用法 C++ List的用法(整理) STL之list容器详解 STL之五：set/multiset用法详解 STL中的set容器的一点总结","categories":[{"name":"学习","slug":"学习","permalink":"http://flame160.git.io/categories/学习/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://flame160.git.io/tags/c/"},{"name":"STL","slug":"STL","permalink":"http://flame160.git.io/tags/STL/"}]},{"title":"关于本博客","slug":"本博客搭建","date":"2015-10-23T10:58:41.000Z","updated":"2018-08-11T08:52:33.939Z","comments":true,"path":"2015/10/23/本博客搭建/","link":"","permalink":"http://flame160.git.io/2015/10/23/本博客搭建/","excerpt":"在大学期间,每天都会接受新的知识,而往往学习之后不久就会忘记,有必要通过博客记录自己的所学所想,也可以将自己的东西分享给其他人。在搭建本博客之前,一般在CSDN上面写博客,虽然在CSDN上写博客比较容易,但是个性化以及在手机上展示性较差。后来看到师兄基于Hexo+Github搭建的博客,觉得排版整洁,个性化精致,然后决定搭建自己的技术性博客。不论作为学生还是工作人员,写博客对于我们来说都是非常最要的事情。你可以记录你成长中的所学、所想、所经历的事情,同时将自己技术、知识、心得、经验分享给其他人,本篇博客将作为一个新的开始。","text":"在大学期间,每天都会接受新的知识,而往往学习之后不久就会忘记,有必要通过博客记录自己的所学所想,也可以将自己的东西分享给其他人。在搭建本博客之前,一般在CSDN上面写博客,虽然在CSDN上写博客比较容易,但是个性化以及在手机上展示性较差。后来看到师兄基于Hexo+Github搭建的博客,觉得排版整洁,个性化精致,然后决定搭建自己的技术性博客。不论作为学生还是工作人员,写博客对于我们来说都是非常最要的事情。你可以记录你成长中的所学、所想、所经历的事情,同时将自己技术、知识、心得、经验分享给其他人,本篇博客将作为一个新的开始。 博客搭建这个博客是基于hexo和github搭建起来的。 搭建这个博客参考已有的教程[1],[2],[3]和[4],这些教程搭建过程比较详细,我也不再重复搭建过程。但是在搭建过程中还是可能会遇到一些问题,这些问题（也许是版本不同导致的）在网上也能轻易的找到相应的解决方案,最后能顺利搭建自己的技术性博客。 博客撰写在github上面搭建博客,使用git和markdown写博客,编辑器为submit,除此之外你可以下载markdownn编辑器,同时还可以使用markdown在线编辑器[1]和[2]。我们还可以在[1]和[2]寻找自己喜欢的主题进行更换。12cd D:\\HexoBloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia Git Bash通过下面的命令，创建新的文章12hexo new 或者 hexo nD:\\HexoBlog\\hexo new 关于本博客 创建完成后你就可以通过markdown写自己的博客。当写好博客后,你需要生成和部署,通过下面的命令123hexo g 或者 hexo generate #生成hexo d 或者 hexo display #部署hexo d -g #在部署前先生成（将两条命令合并） 写这个博客的目的主要作为一个新的开始、同时也为了熟悉一下markdown语法,今后会将自己学习成长过程中的事情记录下来分享给大家。","categories":[{"name":"日志","slug":"日志","permalink":"http://flame160.git.io/categories/日志/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://flame160.git.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://flame160.git.io/tags/git/"}]}]}